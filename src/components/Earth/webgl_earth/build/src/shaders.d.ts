export const commonGLSL: "\n#line 2 0\nconst float pi = 3.1415926535f;\n\nconst float nan     = intBitsToFloat(0xffc00000);\nconst float inf     = intBitsToFloat(0x7f800000);\nconst float one255  = intBitsToFloat(0x3b808081); // 1.f / 255.f\n\nconst int dataImageWidth = 4096;\n\nlayout(std140) uniform UniformBlock\n{\n    // framebuffer:\n    vec2    mainFramebufferSize;\n    vec2 surfaceFramebufferSize;\n\n    // camera:\n    vec4 cameraState;\n    float aspectRatio;\n    float exposure;\n\n    uint commsInfo;\n    uint flags;\n\n    // pick:\n    uint pickInfo;\n    float pickSizeMultiplier;\n    float pickColorMultiplier;\n\n    // earth:\n    uint satLineColor;\n    uint satViewColor;\n    uint satCaptureColor;\n    uint sunsetLineColor;\n    uint borderLineColor;\n\n    // counts:\n    int satelliteCount;\n    int satSampleCount;\n    int   stationCount;\n    int    regionCount;\n    int     commsCount;\n    int  commsMaxCount;\n    int    cameraCount;\n};\n\nvec3 mouse() {return cameraState.xyz;}\nint cameraObjectID() {return floatBitsToInt(cameraState.w);}\n\nuint  commsGroup            () {return        commsInfo & 0x00ffu;}\nfloat commsPointMinimalSize () {return float((commsInfo & 0xff00u) >> 8u) / 15.f;}\n\nbool flag(uint i) {return (flags & (1u << i)) != 0u;}\nbool isPretty               () {return flag(0u);}\nbool isMultisampled         () {return flag(1u);}\nbool isCamera2D             () {return flag(2u);}\nbool isCameraEcliptic       () {return flag(3u);}\nbool isCameraSynchronized   () {return flag(4u);}\n\nuniform  lowp  sampler2D  surfaceA;\n\nuniform  lowp  sampler2D    earthA;\nuniform  lowp  sampler2D    starsA;\nuniform  lowp  sampler2D    bordrA;\nuniform  lowp  sampler2D    milkyA;\nuniform  lowp  sampler2D     gridA;\nuniform  lowp  sampler2D     moonA;\n\nuniform  lowp usampler2D satPointA;\nuniform highp usampler2D satCoordA;\nuniform  lowp usampler2D    groupA;\nuniform highp usampler2D  stationA;\nuniform highp usampler2D   cameraA;\nuniform  lowp usampler2D  captureA;\nuniform  lowp usampler2D    commsA;\nuniform  lowp usampler2D   objectA;\n\nuniform  lowp  sampler2D   regionA;\nuniform highp  sampler2D  polygonA;\nuniform  lowp usampler2D   pickerA;\n#line 2 15\n\nlowp uint uintbyte(uint i, uint n)\n{\n    return (i >> (n << 3)) & 0xffu;\n}\nlowp uvec4 encodeU32(highp uint u)\n{\n    return uvec4\n    (\n        uintbyte(u, 0u),\n        uintbyte(u, 1u),\n        uintbyte(u, 2u),\n        uintbyte(u, 3u)\n    );\n}\n\nvec4 decodeColor(highp uint u)\n{\n    return one255 * vec4(encodeU32(u));\n}\nuint decodeU32(lowp uvec4 u)\n{\n    return u.r\n        | (u.g <<  8u)\n        | (u.b << 16u)\n        | (u.a << 24u);\n}\n\nint   decodeI32(lowp uvec4 u) {return             int(decodeU32(u));}\nfloat decodeF32(lowp uvec4 u) {return uintBitsToFloat(decodeU32(u));}\n\nfloat decodeF24(lowp uvec3 u) {return     decodeF32(uvec4(0x80u, u));}\nint   decodeI24(lowp uvec3 u) {return     decodeI32(uvec4(u, u[2] < 0x80u ? 0u : 0xffu));}\n\nfloat decodeA16(lowp uvec2 u)\n{\n    return float(decodeU32(uvec4(u, 0u, 0u)))\n         / float(0xffffu);\n}\nfloat decodeS16(lowp uvec2 u)\n{\n    return float( ((int(u.r) << 16) | (int(u.g) << 24)) >> 16 )\n         / float(0x7fff);\n}\n\nvec3 decodeOct(vec2 o)\n{\n    vec2 a = abs(o);\n    float z = 1.f - a.x - a.y;\n\n    vec2 r = sign(o) * (1.f - a.yx);\n    vec3 v = vec3((z >= 0.f ? o : r), z);\n    return normalize(v);\n}\n#line 2 27\n\nstruct TimeInterval // difference between two time points in TT time scale\n{\n    float days; // must be an integer value\n    float ms;\n};\n\nconst float  msInSec = 1000.f;\nconst float secInDay = 86400.f;\nconst float  msInDay = msInSec * secInDay;\nconst float dayInCentury = 36525.f;\n\nconst float secInMs  = 1.f / msInSec;\nconst float dayInMs  = 1.f / msInDay;\nconst float dayInSec = 1.f / secInDay;\nconst float centuryInDay = 1.f / dayInCentury;\n\nTimeInterval fromDays(float days)\n{\n    return TimeInterval\n    (\n        floor(days),\n        fract(days) * msInDay\n    );\n}\nfloat toDays(TimeInterval t)\n{\n    return t.days + t.ms * dayInMs;\n}\n\nTimeInterval  fromSeconds       (float sec) {return fromDays(sec * dayInSec);}\nTimeInterval  fromMilliseconds  (float  ms) {return fromDays( ms * dayInMs );}\nfloat toSeconds         (TimeInterval    t) {return toDays(t) * secInDay;}\nfloat toCenturies       (TimeInterval    t) {return toDays(t) * centuryInDay;}\n\nTimeInterval timeSum(TimeInterval t0, TimeInterval t1)\n{\n    float days = t0.days + t1.days;\n    float ms   = t0.ms   + t1.ms;\n    return TimeInterval\n    (\n        ms <= msInDay ? days : days + 1.f,\n        ms <= msInDay ? ms : ms - msInDay\n    );\n}\nTimeInterval timeDiff(TimeInterval t0, TimeInterval t1)\n{\n    float days = t0.days - t1.days;\n    float ms   = t0.ms   - t1.ms;\n    return TimeInterval\n    (\n        ms >= 0.f ? days : days - 1.f,\n        ms >= 0.f ? ms : ms + msInDay\n    );\n}\nfloat timeDiffMs(TimeInterval t0, TimeInterval t1)\n{\n    return (t0.days - t1.days) * msInDay + (t0.ms - t1.ms);\n}\nfloat timeDiffSec(TimeInterval t0, TimeInterval t1)\n{\n    return timeDiffMs(t0, t1) * secInMs;\n}\n\nbool timeLessThan        (TimeInterval t0, TimeInterval t1) {return timeDiffMs(t1, t0) >  0.f;}\nbool timeLessThanEqual   (TimeInterval t0, TimeInterval t1) {return timeDiffMs(t1, t0) >= 0.f;}\nbool timeGreaterThan     (TimeInterval t0, TimeInterval t1) {return timeDiffMs(t1, t0) <  0.f;}\nbool timeGreaterThanEqual(TimeInterval t0, TimeInterval t1) {return timeDiffMs(t1, t0) <= 0.f;}\n\nTimeInterval timeLerp(TimeInterval t0, TimeInterval t1, float k)\n{\n    if(isnan(k))\n        return t0;\n\n    float days = mix(t0.ms, t1.ms, k) * dayInMs + k * (t1.days - t0.days);\n    return TimeInterval\n    (\n        t0.days + floor(days),\n        msInDay * fract(days)\n    );\n}\nfloat timeUnlerp(TimeInterval t0, TimeInterval t1, TimeInterval t)\n{\n    return timeDiffMs(t, t0) / timeDiffMs(t1, t0);\n}\n\nfloat toPhase(float nu, TimeInterval t) // -> mod2pi(nu * t)\n                                        // -> 2pi * fract(nu * t / 2pi)\n                                        // -> 2pi * fract(w * t)\n                                        // -> 2pi * fract(w * (86400 * days + 0.001 * ms))\n{\n    float w = fract(nu * secInDay / (2.f * pi));\n    return 2.f * pi * fract(w * float(t.days)) + t.ms * nu * secInMs;\n}\n\nstruct Time\n{\n    int epoch;\n    TimeInterval interval;\n};\n\nuniform float TTminusUT; // TT and UT1 millisecond difference for current frame\nuniform Time  now; // current  frame\nuniform Time prev; // previous frame\n\n#define epochJ2000 0\n#define epochUnix  1\n/*\n#define epochJ1900 2\n#define epochB1900 3\n#define epochB1950 4\n*/\n#define epochCount 2\n// epoch:\n// J2000: 01.01.2000 12:00:00     TT  (Julian Day 2451545.0)\n//     or 01.01.2000 11:58:55.816 UTC\n// J1900: 00.01.1900 12:00:00     TT  (Julian Day 2415020.0)\n// B1900: 00.01.1900 19:31:26.4   TT  (Julian Day 2415020.3135)\n// B1950: 00.01.1950 22:09:50.4   TT  (Julian Day 2433282.4235)\n//  Unix: 01.01.1970 00:00:00     UTC\nconst TimeInterval epochDiff[epochCount] = TimeInterval[epochCount] // epoch[0] - epoch[i]\n(\n    TimeInterval(    0.f,        0.f),\n    \n    TimeInterval(10957.f, 43157816.f) // 946727957.816 seconds: 10597 * 86400 + 43200 + 22 - (32.184 + 10 + 22)\n                                      // TT - TAI = 32.184, TAI - UTC = 10 (constant) + 22 (leap, 01.01.2000)\n    /*\n    TimeInterval(36525.f,    22000.f),\n    TimeInterval(36524.f, 59335600.f),\n    TimeInterval(18262.f, 49831600.f),\n    */\n);\nTimeInterval timeSinceJ2000(Time time)\n{\n    return timeDiff(time.interval, epochDiff[time.epoch]);\n}\nTime fromJ2000To(int epoch, TimeInterval t)\n{\n    return Time(epoch, timeSum(t, epochDiff[epoch]));\n}\n#line 2 22\nvec2 fromAngles(float longitude, float latitude)\n{\n    return vec2(longitude, latitude);\n}\nvec3 toS2(vec2 a)\n{\n    vec3 s2 = vec3\n    (\n        cos(a.y) * cos(a.x),\n        cos(a.y) * sin(a.x),\n        sin(a.y)\n    );\n    return normalize(s2);\n}\nvec2 fromS2(vec3 n)\n{\n    float theta = asin(n.z);\n    return vec2\n    (\n        atan(n.y / cos(theta), n.x / cos(theta)),\n        theta\n    );\n}\nvec2 toUV(vec2 a)\n{\n    return vec2\n    (\n        a.x / (2.f * pi) + 0.5f,\n        0.5f - a.y / pi\n    );\n}\nvec2 fromUV(vec2 a)\n{\n    return vec2\n    (\n        (a.x - 0.5f) * 2.f * pi,\n        (0.5f - a.y) * pi\n    );\n}\n#line 2 20\nstruct Ray\n{\n    vec3 pos;\n    vec3 dir;\n};\nvec3 rayPoint(Ray ray, float t)\n{\n    return ray.pos + ray.dir * t;\n}\n\nstruct HeavyRay\n{\n    vec3 pos;\n    vec3 dir;\n    vec3 invDir;\n};\nRay rayFrom(HeavyRay ray)\n{\n    return Ray(ray.pos, ray.dir);\n}\nHeavyRay heavyRayFrom(Ray ray)\n{\n    return HeavyRay\n    (\n        ray.pos,\n        ray.dir,\n        1.f / ray.dir\n    );\n}\n\nstruct RayDistanceRange\n{\n    float tNear, tFar;\n};\n\nRayDistanceRange mergeRange(RayDistanceRange r1, RayDistanceRange r2)\n{\n    return RayDistanceRange\n    (\n        r1.tNear > r2.tNear ? r1.tNear : r2.tNear,\n        r1.tFar  < r2.tFar  ? r1.tFar  : r2.tFar\n    );\n}\n\nbool nonempty(RayDistanceRange rdr         ) {return rdr.tNear      <=      rdr.tFar;}\nbool contains(RayDistanceRange rdr, float t) {return rdr.tNear <= t && t <= rdr.tFar;}\n\nconst RayDistanceRange zeroToInf  = RayDistanceRange(0.f,  inf);\nconst RayDistanceRange emptyRange = RayDistanceRange(0.f, -1.f);\n\nbool happened(RayDistanceRange rdr) {return nonempty(mergeRange(zeroToInf, rdr));}\n\nstruct Sphere\n{\n    vec3 origin;\n    float radius;\n};\nRayDistanceRange raySphereIntersection(Ray ray, Sphere sphere)\n{\n    vec3 p = ray.pos - sphere.origin;\n    float dp = dot(ray.dir, p);\n    float det = dp * dp - dot(p, p) + sphere.radius * sphere.radius;\n    if(det < 0.f)\n        return emptyRange;\n    return RayDistanceRange\n    (\n        -dp - sqrt(det),\n        -dp + sqrt(det)\n    );\n}\n\nfloat lightVisibility(vec3 r, Sphere light, Sphere occluder)\n    // assuming light.radius > occluder.radius\n{\n    // avoid float exponent overflow:\n    float invR = 1.f / occluder.radius;\n    r *= invR;\n    light.origin *= invR;\n    light.radius *= invR;\n    occluder.origin *= invR;\n    occluder.radius = 1.f;\n\n    vec3 ro = r               - occluder.origin;\n    vec3 rl = r               -    light.origin;\n    vec3 ol = occluder.origin -    light.origin;\n\n    float ro2  = dot(ro, ro);\n    float rl2  = dot(rl, rl);\n    float ol2  = dot(ol, ol);\n    float rool = dot(ro, ol);\n\n    if(rool < 0.f)\n        return 1.f;\n\n    float rp = light.radius + occluder.radius;\n    float rm = light.radius - occluder.radius;\n\n    float d2Umb = ol2 * (occluder.radius * occluder.radius) / (rm * rm);\n    float d2Pen = ol2 * (occluder.radius * occluder.radius) / (rp * rp);\n\n    float tg2Umb = (rm * rm) / (ol2 - rm * rm);\n    float tg2Pen = (rp * rp) / (ol2 - rp * rp);\n\n    float d2 = rool * rool / ol2;\n    float h2 = ro2 - d2;\n\n    float h2Umb = (d2Umb - 2.f * rool * occluder.radius / rm + d2) * tg2Umb;\n    float h2Pen = (d2Pen + 2.f * rool * occluder.radius / rp + d2) * tg2Pen;\n\n    /* a correct one is\n    float t = (sqrt(h2)    - sqrt(h2Pen))\n            / (sqrt(h2Umb) - sqrt(h2Pen));\n     * but it has clearly visible precision problems */\n    float t = (h2    - h2Pen)\n            / (h2Umb - h2Pen);\n    float x = clamp(t, 0.f, 1.f);\n\n    float areaRatio = occluder.radius * occluder.radius * rl2\n                    / (  light.radius *    light.radius * ro2);\n // return min(areaRatio, 1.f) * x * x     * (2.f - x); // works better if t ~ h\n    return 1.f - min(areaRatio, 1.f) * x * x * x * (2.f - x); // works better if t ~ h^2\n}\n\nstruct Cylinder\n{\n    vec3 r0, r1;\n    float radius;\n};\nRayDistanceRange rayCylinderIntersection(Ray ray, Cylinder cylinder)\n{\n    vec3 e = ray.pos - cylinder.r0;\n    vec3 l = normalize(cylinder.r1 - cylinder.r0);\n\n    float dl = dot(ray.dir, l);\n    float el = dot(e, l);\n    float l2 = dot(l, l);\n\n    float a = 1.f - dl * dl;\n    float b = dot(ray.dir, e) - dl * el;\n    float c = dot(e, e) - cylinder.radius * cylinder.radius - el * el;\n    float det = b * b - a * c;\n    if(det < 0.f)\n        return emptyRange;\n\n    vec4 t = vec4\n    (\n        (-b - sqrt(det)) / a,\n        (-b + sqrt(det)) / a,\n        dot(cylinder.r0 - ray.pos, l) / dl,\n        dot(cylinder.r1 - ray.pos, l) / dl\n    );\n    return RayDistanceRange\n    (\n        max(min(t[0], t[1]), min(t[2], t[3])),\n        min(max(t[0], t[1]), max(t[2], t[3]))\n    );\n}\n\nstruct AABB\n{\n    vec3 pmin, pmax;\n};\nRayDistanceRange rayAABBIntersection(HeavyRay ray, AABB box, RayDistanceRange rdr)\n{\n    vec3 a = (box.pmin - ray.pos) * ray.invDir;\n    vec3 b = (box.pmax - ray.pos) * ray.invDir;\n    vec4 tMin = vec4\n    (\n        min(a.x, b.x),\n        min(a.y, b.y),\n        min(a.z, b.z),\n        rdr.tNear\n    );\n    vec4 tMax = vec4\n    (\n        max(a.x, b.x),\n        max(a.y, b.y),\n        max(a.z, b.z),\n        rdr.tFar\n    );\n    return RayDistanceRange\n    (\n        max(tMin[0], max(tMin[1], max(tMin[2], tMin[3]))),\n        min(tMax[0], min(tMax[1], min(tMax[2], tMax[3])))\n    );\n}\nRayDistanceRange rayAABBIntersection(Ray ray, AABB box, RayDistanceRange rdr)\n{\n    return rayAABBIntersection(heavyRayFrom(ray), box, rdr);\n}\n\nstruct Triangle\n{\n    vec3 r0, r1, r2;\n};\nstruct RayTriangleIntersection\n{\n    float t, p, q;\n};\nbool happened(RayTriangleIntersection i) {return i.p >= 0.f && i.q >= 0.f && i.p + i.q <= 1.f;}\nfloat intersectionDistance(RayTriangleIntersection i) {return i.t;}\n\n// ray: r = o - d * t\n// triangle: r - r0 = p * (r1 - r0) + q * (r2 - r0)\n// substitute: o - d * t - r0 = p * (r1 - r0) + q * (r2 - r0)\n// o - r0 = d * t + p * (r1 - r0) + q * (r2 - r0)\n// c = d * t + p * a + q * b\n// mat3(d, a, b) * vec3(t, p, q) = c\nRayTriangleIntersection rayTriangleIntersection(Ray ray, Triangle triangle, RayDistanceRange rdr)\n{\n    const RayTriangleIntersection miss = RayTriangleIntersection(-1.f, -1.f, -1.f);\n\n    vec3 a = triangle.r1 - triangle.r0;\n    vec3 b = triangle.r2 - triangle.r0;\n    vec3 c =     ray.pos - triangle.r0;\n    vec3 d = -ray.dir;\n\n    float det0 = dot(d, cross(a, b));\n\n    RayTriangleIntersection hit = RayTriangleIntersection\n    (\n        dot(c, cross(a, b)) / det0,\n        dot(d, cross(c, b)) / det0,\n        dot(d, cross(a, c)) / det0\n    );\n\n    if(contains(rdr, hit.t))\n        return hit;\n    else\n        return miss;\n}\nRayTriangleIntersection rayTriangleIntersection(HeavyRay ray, Triangle triangle, RayDistanceRange rdr)\n{\n    return rayTriangleIntersection(rayFrom(ray), triangle, rdr);\n}\n#line 2 21\nmat3 rotateX(float phi)\n{\n    return mat3\n    (\n        vec3(1.f, 0.f, 0.f),\n        vec3(0.f, cos(phi), -sin(phi)),\n        vec3(0.f, sin(phi),  cos(phi))\n    );\n}\nmat3 rotateY(float phi)\n{\n    return mat3\n    (\n        vec3(cos(phi), 0.f, -sin(phi)),\n        vec3(0.f, 1.f, 0.f),\n        vec3(sin(phi), 0.f,  cos(phi))\n    );\n}\nmat3 rotateZ(float phi)\n{\n    return mat3\n    (\n        vec3(cos(phi), -sin(phi), 0.f),\n        vec3(sin(phi),  cos(phi), 0.f),\n        vec3(0.f, 0.f, 1.f)\n    );\n}\n#line 2 14\n\nconst float   sunR = 6.957e8f;\nconst float  moonR = 1.737e6f;\nconst float earthR = 6.371e6f;\nconst float  atmoH = 5.150e4f;\n\nconst float   sunMu = 1.3271244e20f;\nconst float  moonMu = 4.9048695e12f;\nconst float earthMu = 3.9860044e14f;\n\nfloat GMST(Time time)\n{\n    TimeInterval t = timeSinceJ2000(time);\n\n    const float dayInTropicalYear = 2.7379093e-3f;\n    return -1.3882241f + 2.f * pi *\n    (\n        (t.ms - TTminusUT) * (dayInMs * (1.f + dayInTropicalYear))\n      + fract(float(t.days) * dayInTropicalYear)\n    );\n}\n\nstruct EclipticCoord\n{\n    vec2 coord; // longitude and latitude\n    float dist;\n};\nvec3 eclipticPosition(EclipticCoord ec)\n{\n    return ec.dist * toS2(ec.coord);\n}\n\nEclipticCoord sunEclipticCoord(Time time)\n{\n    TimeInterval t = timeSinceJ2000(time);\n    float tc  = toCenturies(t);\n\n    float e   =  0.01670862f - tc * (4.2037e-5f + tc * 1.236e-7f);\n    float M   = -0.04318531f + toPhase(1.9909689e-7f, t);\n    float phi = -1.38823488f + toPhase(1.9910638e-7f, t)\n              +  e * 2.f     * sin(      M)\n              +  0.00034897f * sin(2.f * M);\n    float r   =  1.00014061f\n              -  e           * cos(      M)\n              -  0.00013959f * cos(2.f * M);\n    return EclipticCoord(vec2(phi, 0.f), 1.4959787e11f * r);\n}\nmat3 moonRotation(Time time)\n{\n    TimeInterval t = timeSinceJ2000(time);\n\n    float l = -2.4727853f + toPhase(2.661707e-6f, t);\n    float f = -4.6551853f + toPhase(2.672404e-6f, t);\n    return rotateZ(f + pi) * rotateX(0.02692f) * rotateZ(l - f);\n}\nEclipticCoord moonEclipticCoord(Time time)\n{\n    TimeInterval t = timeSinceJ2000(time);\n\n    float m = - 0.0531853f + toPhase(1.990969e-7f, t);\n    float n = - 3.9277853f + toPhase(2.639203e-6f, t);\n    float f = - 4.6551853f + toPhase(2.672404e-6f, t);\n    float d = - 1.0846853f + toPhase(2.462601e-6f, t);\n\n    float a = - 2.4727853f + toPhase(2.661707e-6f, t)\n              + 0.1098f * sin(n)\n              + 0.0222f * sin(2.f * d - n)\n              + 0.0115f * sin(2.f * d)\n              + 0.0037f * sin(2.f * n)\n              - 0.0032f * sin(m)\n              - 0.0020f * sin(2.f * f)\n              + 0.0010f * sin(2.f * d - 2.f * n)\n              + 0.0010f * sin(2.f * d - m - n)\n              + 0.0009f * sin(2.f * d + n)\n              + 0.0008f * sin(2.f * d - m)\n              + 0.0007f * sin(n - m)\n              - 0.0006f * sin(d)\n              - 0.0005f * sin(m + n);\n    float b =   0.0895f * sin(f)\n              + 0.0049f * sin(n + f)\n              + 0.0048f * sin(n - f)\n              + 0.0030f * sin(2.f * d - f)\n              + 0.0010f * sin(2.f * d + f - n)\n              + 0.0008f * sin(2.f * d - f - n)\n              + 0.0006f * sin(2.f * d + f);\n    float c =   0.016593f\n              + 0.000904f * cos(n)\n              + 0.000166f * cos(2.f * d - n)\n              + 0.000137f * cos(2.f * d)\n              + 0.000049f * cos(2.f * n)\n              + 0.000015f * cos(2.f * d + n)\n              + 0.000009f * cos(2.f * d - m);\n    return EclipticCoord(vec2(a, b), earthR / c);\n}\n#line 2 24\nvec3 satPositionNow (int satI) {return uintBitsToFloat(texelFetch(satCoordA, ivec2(satI % 4096,     4 * (satI / 4096)), 0).rgb);}\nvec3 satVelocityNow (int satI) {return uintBitsToFloat(texelFetch(satCoordA, ivec2(satI % 4096, 1 + 4 * (satI / 4096)), 0).rgb);}\nvec3 satPositionPrev(int satI) {return uintBitsToFloat(texelFetch(satCoordA, ivec2(satI % 4096, 2 + 4 * (satI / 4096)), 0).rgb);}\nvec3 satVelocityPrev(int satI) {return uintBitsToFloat(texelFetch(satCoordA, ivec2(satI % 4096, 3 + 4 * (satI / 4096)), 0).rgb);}\n#line 2 10\n\nconst mat3 fromEcliptic = mat3\n(\n    vec3(1.f, 0.f, 0.f),\n    vec3(0.f,  0.9174819f, 0.3977773f),\n    vec3(0.f, -0.3977773f, 0.9174819f)\n);\n\nstruct Hyperbola\n{\n    float k;\n    float fmin, fmax;\n    bool ascend;\n};\nfloat eval(Hyperbola hyp, float z)\n{\n    float det = 0.25 - hyp.k / (hyp.fmax - hyp.fmin);\n    float c2 = hyp.ascend\n        ? -0.5 - sqrt(det)\n        : -0.5 + sqrt(det);\n    float c1 = hyp.fmin - hyp.k / c2;\n    return c1 + hyp.k / (z + c2);\n}\nfloat fov(float z)\n{\n    const Hyperbola h = Hyperbola(-1.f, 0.05f, 0.7f, false);\n    return eval(h, z);\n}\nfloat camDist(float z)\n{\n    const Hyperbola h1 = Hyperbola(-10.f, 1.f, 10.f, true);\n    const Hyperbola h2 = Hyperbola(-10.f, 3.f, 40.f, true);\n    return isCamera2D()\n        ? eval(h1, z)\n        : eval(h2, z) * (cameraObjectID() == -2 ? moonR\n                      : (cameraObjectID() == -1 ? earthR\n                                                : 1e3f));\n}\n\nmat3 cameraBasis()\n{\n    mat3 M = isCameraSynchronized()\n        ? rotateZ(-GMST(now))\n        : mat3\n    (\n        1.f, 0.f, 0.f,\n        0.f, 1.f, 0.f,\n        0.f, 0.f, 1.f\n    );\n    if(isCameraEcliptic())\n        M *= fromEcliptic;\n\n    if(cameraObjectID() >= 0)\n    {\n        vec3 x = normalize(satPositionNow(cameraObjectID()));\n        vec3 z = normalize(cross(x, satVelocityNow(cameraObjectID())));\n        M = mat3(x, cross(z, x), z);\n    }\n\n    vec3 camZ = M * toS2(fromAngles(pi * mouse().x, 0.5f * pi * mouse().y));\n    vec3 camX = normalize(cross(M[2], camZ));\n    return mat3(camX, cross(camZ, camX), camZ);\n}\nvec3 cameraAt()\n{\n    return cameraObjectID() == -2\n        ? fromEcliptic * eclipticPosition(moonEclipticCoord(now))\n        : (cameraObjectID() == -1\n            ? vec3(0.f)\n            : satPositionNow(cameraObjectID()));\n}\nvec3 cameraPos()\n{\n    return cameraAt() + cameraBasis()[2] * camDist(mouse().z);\n}\nRay cameraRay(vec2 pixel)\n{\n    if(isCamera2D())\n    {\n        float k = camDist(mouse().z) / camDist(1.f);\n        vec2 uv0 = vec2\n        (\n            0.5f + 0.5f * (mouse().x + GMST(now) / pi),\n            0.5f + 0.5f * (k - 1.f) * mouse().y\n        );\n        vec2 uv = uv0 + vec2(0.5f, -0.5f) * pixel * k;\n        vec3 n = toS2(fromUV(uv));\n        return Ray(n * earthR * 1.001f, -n);\n    }\n\n    mat3 B = cameraBasis();\n    return Ray\n    (\n        cameraPos(),\n        mat3(-B[2], B[0], B[1]) * toS2(fov(mouse().z) * pixel * vec2(aspectRatio, 1.f))\n      //mat3(B[0], B[1], B[2]) * normalize(vec3(fov(mouse().z) * pixel * vec2(aspectRatio, 1.f), -1.f))\n    );\n}\nfloat toDepth(float z) // [near, far] -> [0, 1]\n{\n    if(isCamera2D())\n        return 1.f;\n\n    float near = earthR * 5e-4f;\n    float far  = earthR * 5e2f;\n    float c1 =        far / (far - near);\n    float c2 = near * far / (far - near);\n    return c1 - c2 / z;\n}\nfloat pointDepth(vec3 pos)\n{\n    return toDepth(-dot(cameraBasis()[2], pos - cameraPos()));\n}\nvec3 cameraPixel(vec3 pos)\n{\n    if(isCamera2D())\n    {\n        float k = camDist(mouse().z) / camDist(1.f);\n        vec2 uv0 = vec2\n        (\n            0.5f + 0.5f * mouse().x + 0.5f * GMST(now) / pi,\n            0.5f + 0.5f * (k - 1.f) * mouse().y\n        );\n        vec2 uv = toUV(fromS2(normalize(pos)));\n        vec2 p = vec2(2.f, -2.f) * (uv - uv0);\n        p.x = -1.f + 2.f * fract(0.5f + 0.5f * p.x);\n        return vec3(p / k, 1.f);\n    }\n\n    mat3 B = cameraBasis();\n    vec3 dir = transpose(mat3(-B[2], B[0], B[1])) * normalize(pos - cameraPos());\n    vec2 uv = fromS2(dir);\n  //vec3 dir = transpose(mat3(B[0], B[1], B[2])) * normalize(pos - cameraPos());\n  //vec2 uv = dir.xy / (-dir.z);\n    return vec3\n    (\n        uv / fov(mouse().z) / vec2(aspectRatio, 1.f),\n        -1.f + 2.f * pointDepth(pos) // [-1, 1]\n    );\n}\n#line 2 11\n\nlowp uvec4 fetchCapturePixel(int i)\n{\n    return texelFetch(captureA, ivec2(i % dataImageWidth, i / dataImageWidth), 0);\n}\nlowp uvec2 fetchCapturePixelHalf(int i)\n{\n    lowp uvec4 u = fetchCapturePixel(i / 2);\n    return i % 2 == 0\n        ? u.xy\n        : u.zw;\n}\n\nstruct ByteRange\n{\n    int begin, end; // offset in bytes\n};\nint rangeSize(ByteRange range, int entrySize)\n{\n    return (range.end - range.begin) / entrySize;\n}\nByteRange captureRange(int cameraI)\n{\n    return ByteRange\n    (\n        decodeI32(fetchCapturePixel(cameraI + 1)),\n        decodeI32(fetchCapturePixel(cameraI + 2))\n    );\n}\n\nstruct CaptureInfo\n{\n    // J2000:\n    float days;\n    float ms0, ms1;\n    ByteRange angleR;\n};\nCaptureInfo captureInfo(ByteRange captureR, int captureI)\n{\n    int i = captureR.begin / 4 + captureI * 5;\n    return CaptureInfo\n    (\n        decodeF32(fetchCapturePixel(i    )),\n        decodeF32(fetchCapturePixel(i + 1)),\n        decodeF32(fetchCapturePixel(i + 2)),\n        ByteRange\n        (\n            decodeI32(fetchCapturePixel(i + 3)),\n            decodeI32(fetchCapturePixel(i + 4))\n        )\n    );\n}\n\nint captureLowerBound(ByteRange captureR, TimeInterval t)\n{\n    ivec2 it = ivec2(0, rangeSize(captureR, 20));\n    while(it[0] != it[1])\n    {\n        int mid = (it[0] + it[1]) >> 1;\n        CaptureInfo i = captureInfo(captureR, mid);\n        it = timeLessThanEqual(t, TimeInterval(i.days, i.ms1))\n            ? ivec2(it[0],     mid)\n            : ivec2(mid + 1, it[1]);\n    }\n    return it[0];\n}\n\nfloat angle(ByteRange angleR, int i)\n{\n    return decodeA16(fetchCapturePixelHalf(angleR.begin / 2 + i));\n}\nfloat interpolate(CaptureInfo capture, TimeInterval t)\n{\n    int angleCount = rangeSize(capture.angleR, 2);\n    TimeInterval t1 = TimeInterval(capture.days, capture.ms1);\n\n    float n = float(angleCount - 1) * (1.f - timeDiffMs(t1, t) / (capture.ms1 - capture.ms0));\n    int   i = clamp(int(n), 0, angleCount - 2);\n    return mix\n    (\n        angle(capture.angleR, i    ),\n        angle(capture.angleR, i + 1),\n        n - float(i)\n    );\n}\nfloat interpolatedAngle(int cameraI, Time time)\n{\n    ByteRange captureR = captureRange(cameraI);\n    TimeInterval t = timeSinceJ2000(time);\n    int captureI = captureLowerBound(captureR, t);\n    if(captureI == rangeSize(captureR, 20))\n        return nan;\n    CaptureInfo capture = captureInfo(captureR, captureI);\n    return timeLessThanEqual(TimeInterval(capture.days, capture.ms0), t)\n        ? interpolate(capture, t)\n        : nan;\n}\n\n#ifndef FRAGSHADER\nstruct CameraInfo\n{\n    int satelliteID;\n    float captureAngle;\n    vec2 viewAngle;\n    vec2 captureOrientation; // interpolatedAngle(now), (prev)\n};\nCameraInfo cameraInfo(int cameraI)\n{\n    int i = cameraCount + 2 + 4 * cameraI;\n    uvec3 u = texelFetch(cameraA, ivec2(cameraI, 0), 0).rgb;\n    return CameraInfo\n    (\n        int(u.z),\n        decodeF32(fetchCapturePixel(i + 1)),\n        vec2\n        (\n            decodeF32(fetchCapturePixel(i + 2)),\n            decodeF32(fetchCapturePixel(i + 3))\n        ),\n        uintBitsToFloat(u.xy)\n    );\n}\n#endif\n#line 2 12\n\nconst vec3 wl = vec3(615.f, 535.f, 445.f) * 1e-9f; // spectral representation wavelengths\nconst mat3 spectralToSRGB = mat3 // spectral -> sRGB (including E -> D65)\n(\n     1.6218f, -0.0374f, -0.0283f,\n    -0.4493f,  1.0598f, -0.1119f,\n     0.0325f, -0.0742f,  1.0491f\n);\nconst mat3 sRGBtoSpectral = inverse(spectralToSRGB);\n\nconst vec3 sunSpectral = vec3(0.3147f, 0.3431f, 0.3422f);\nconst vec3 sunSRGB = spectralToSRGB * sunSpectral;\n\nvec3 expose(vec3 x)\n{\n    const mat3 m1 = mat3\n    (\n        0.59719f, 0.07600f, 0.02840f,\n        0.35458f, 0.90834f, 0.13383f,\n        0.04823f, 0.01566f, 0.83777f\n    );\n    const mat3 m2 = mat3\n    (\n         1.60475f, -0.10208f, -0.00327f,\n        -0.53108f,  1.10813f, -0.07276f,\n        -0.07367f, -0.00605f,  1.07602f\n    );\n    vec3 v = m1 * x * exposure;\n    vec3 a = v * (v + 0.0245786f) - 0.000090537f;\n    vec3 b = v * (0.983729f * v + 0.432951f) + 0.238081f;\n    return clamp(m2 * (a / b), 0.f, 1.f);\n}\n\nvec3 decodeSRGB(vec3 color)\n{\n    return mix\n    (\n        color / 12.92f,\n        pow((color + 0.055f) / 1.055f, vec3(2.4f)),\n        step(vec3(0.04045f), color)\n    );\n}\nvec3 encodeSRGB(vec3 color)\n{\n    return mix\n    (\n        12.92f * color,\n        1.055f * pow(color, vec3(1.f / 2.4f)) - 0.055f,\n        step(vec3(0.0031308f), color)\n    );\n}\n#line 2 13\n\nlowp uvec3 fetchObjectPixel(int i)\n{\n    return texelFetch(objectA, ivec2(i % dataImageWidth, i / dataImageWidth), 0).rgb;\n}\nvec3 fetchA16x3(int i)\n{\n    uvec3 u0 = fetchObjectPixel(i);\n    uvec3 u1 = fetchObjectPixel(i + 1);\n    return vec3\n    (\n        decodeA16(u0.xy),\n        decodeA16(uvec2(u0.z, u1.x)),\n        decodeA16(u1.yz)\n    );\n}\nvec3 fetchS16x3(int i)\n{\n    uvec3 u0 = fetchObjectPixel(i);\n    uvec3 u1 = fetchObjectPixel(i + 1);\n    return vec3\n    (\n        decodeS16(u0.xy),\n        decodeS16(uvec2(u0.z, u1.x)),\n        decodeS16(u1.yz)\n    );\n}\nint fetchObjectOffset(int objectI)\n{\n    return decodeI24(fetchObjectPixel(objectI));\n}\nAABB fetchObjectMainAABB(int objectI)\n{\n    int off = fetchObjectOffset(objectI);\n    return AABB\n    (\n        vec3\n        (\n            decodeF24(fetchObjectPixel(off + 1)),\n            decodeF24(fetchObjectPixel(off + 2)),\n            decodeF24(fetchObjectPixel(off + 3))\n        ),\n        vec3\n        (\n            decodeF24(fetchObjectPixel(off + 4)),\n            decodeF24(fetchObjectPixel(off + 5)),\n            decodeF24(fetchObjectPixel(off + 6))\n        )\n    );\n}\nint fetchTriangleCount(int objectI)\n{\n    return decodeI24(fetchObjectPixel(fetchObjectOffset(objectI)));\n}\nAABB fetchObjectAABB(int objectI, uint i)\n{\n    int off = fetchObjectOffset(objectI) + 7;\n    int i0 = off + 4 * int(i);\n    return AABB\n    (\n        fetchA16x3(i0    ),\n        fetchA16x3(i0 + 2)\n    );\n}\nTriangle fetchObjectTriangle(int objectI, uint i)\n{\n    int triangleCount = fetchTriangleCount(objectI);\n    int off = fetchObjectOffset(objectI) + 3 + 8 * triangleCount;\n    int i0 = off + 6 * int(i);\n    return Triangle\n    (\n        fetchA16x3(i0    ),\n        fetchA16x3(i0 + 2),\n        fetchA16x3(i0 + 4)\n    );\n}\nvec3 fetchObjectNorm(int objectI, uint i, RayTriangleIntersection rti)\n{\n    int triangleCount = fetchTriangleCount(objectI);\n    int off = fetchObjectOffset(objectI) + 3 + 14 * triangleCount;\n    int i0 = off + 4 * int(i);\n    vec3 v0 = fetchS16x3(i0);\n    vec3 v1 = fetchS16x3(i0 + 2);\n    vec3 n0 = decodeOct(v0.xy);\n    vec3 n1 = decodeOct(vec2(v0.z, v1.x));\n    vec3 n2 = decodeOct(v1.yz);\n\n    return (1.f - rti.p - rti.q) * n0\n                + rti.p          * n1\n                        + rti.q  * n2;\n}\n\nstruct Material\n{\n    vec3 albedo;\n    float roughness;\n    float metalness;\n};\nMaterial fetchTriangleMaterial(int objectI, uint i)\n{\n    int triangleCount = fetchTriangleCount(objectI);\n    int off = fetchObjectOffset(objectI) + 3 + 18 * triangleCount;\n    uvec3 m = fetchObjectPixel(off + int(i));\n    return Material\n    (\n        vec3\n        (\n            float(m.x >> 3u) / 31.f,\n            float(((m.x & 0x7u) << 3u) | (m.y >> 5u)) / 63.f,\n            float(m.y & 0x1fu) / 31.f\n        ),\n        float(m.z & 0x3fu) /  63.f,\n        float(m.z & 0xc0u) / 192.f\n    );\n}\n\nuint ctz(uint n)\n{\n    uint m = -n & n;\n    return 32u - ((m & 0x0000FFFFu) != 0u ? 16u : 0u)\n               - ((m & 0x00FF00FFu) != 0u ?  8u : 0u)\n               - ((m & 0x0F0F0F0Fu) != 0u ?  4u : 0u)\n               - ((m & 0x33333333u) != 0u ?  2u : 0u)\n               - ((m & 0x55555555u) != 0u ?  1u : 0u)\n               - ( m                != 0u ?  1u : 0u);\n}\n\nstruct RayObjectIntersection\n{\n    uint triangleID;\n    RayTriangleIntersection rti;\n};\nbool happened(RayObjectIntersection i) {return i.triangleID != uint(-1);}\nfloat intersectionDistance(RayObjectIntersection i) {return intersectionDistance(i.rti);}\n\nRayObjectIntersection rayObjectIntersection(int objectI, HeavyRay ray, RayDistanceRange rdr)\n{\n    RayObjectIntersection result = RayObjectIntersection(uint(-1), RayTriangleIntersection(0.f, 0.f, 0.f));\n\n    // stackless traversal based on Rasmus Barringer's paper:\n    // https://jcgt.org/published/0002/01/03/paper.pdf\n    // https://github.com/Woking-34/dynamic-stackless-binary-tree-traversal\n\n    uint node     = 1u; // current node; indexing from 1, easier to go up: node >>= up\n    uint traverse = 0u; // helps to evaluate up count\n\n    uint triangleCount = uint(fetchTriangleCount(objectI));\n    while(true)\n    {\n        if(node < triangleCount)\n        {\n            RayDistanceRange iLeft  = rayAABBIntersection(ray, fetchObjectAABB(objectI, 2u * node - 1u), rdr);\n            RayDistanceRange iRight = rayAABBIntersection(ray, fetchObjectAABB(objectI, 2u * node     ), rdr);\n            bool bLeft  = nonempty(iLeft );\n            bool bRight = nonempty(iRight);\n\n            if(bLeft || bRight)\n            {\n                traverse = 2u * traverse + (bLeft ^^ bRight ? 1u : 0u);\n                node = !bRight || (bLeft && iLeft.tNear <= iRight.tNear)\n                    ? 2u * node\n                    : 2u * node + 1u;\n                continue;\n            }\n        }\n        else\n        {\n            uint i = node - triangleCount;\n            RayTriangleIntersection intersection = rayTriangleIntersection(ray, fetchObjectTriangle(objectI, i), rdr);\n            if(happened(intersection))\n            {\n                rdr.tFar = intersectionDistance(intersection);\n                result = RayObjectIntersection(i, intersection);\n            }\n        }\n\n        uint up = ctz(++traverse);\n        traverse >>= up;\n        node     >>= up;\n\n        if(node <= 1u)\n            return result;\n\n        node = node + 1u - ((node & 1u) << 1u); // node = sibling(node);\n    }\n}\nRayObjectIntersection rayObjectIntersection(int objectI, Ray ray, RayDistanceRange rdr)\n{\n    return rayObjectIntersection(objectI, heavyRayFrom(ray), rdr);\n}\n#line 2 18\n\nstruct vec7\n{\n    vec3 r;\n    vec3 v;\n    TimeInterval t; // J2000\n};\n\nstruct Orbit\n{\n    vec3 x, y;\n    float e;\n    float n;\n    float E0;\n    TimeInterval t0; // J2000\n};\n\nOrbit orbitFromVec7(vec7 point) // ECI\n{\n    vec3 c = cross(point.r, point.v);\n\n    vec3 r = normalize(point.r);\n    vec3 e = cross(point.v, c) / earthMu - r;\n    float e2 = dot(e, e);\n\n    vec3 ex = e2 > 1e-7f ? normalize(e) : r;\n    vec3 ey = cross(normalize(c), ex);\n\n    float p = dot(c, c) / earthMu;\n    float a = p /     (1.f - e2);\n    float b = a * sqrt(1.f - e2);\n\n    float sinE0 = dot(point.r, ey) / b;\n    float cosE0 = dot(point.r, ex) / a + sqrt(e2);\n\n    return Orbit\n    (\n        ex * a,\n        ey * b,\n        sqrt(e2),\n        sqrt(earthMu / (a * a * a)),\n        atan(sinE0, cosE0),\n        point.t\n    );\n}\n\nfloat solveKeplerian(float M, float e)\n{\n    float E = sin(M) < 0.f\n        ? M - e\n        : M + e;\n\n    for(uint i = 0u; i < 5u; ++i)\n        E -= (E - e * sin(E) - M) / (1.f - e * cos(E));\n    return E;\n}\nfloat orbitPeriod(Orbit orbit)\n{\n    return 2.f * pi / orbit.n;\n}\nfloat orbitEccentricAnomaly(Orbit orbit, Time time)\n{\n    float ndt = toPhase(orbit.n, timeDiff(timeSinceJ2000(time), orbit.t0));\n    float M = ndt + orbit.E0 - orbit.e * sin(orbit.E0);\n    return solveKeplerian(M, orbit.e);\n}\nfloat orbitTime(Orbit orbit, float E)\n{\n    return (E - orbit.e * sin(E)) / orbit.n;\n}\n\nvec3 orbitPoint(Orbit orbit, float E)\n{\n    return orbit.x * (cos(E) - orbit.e)\n         + orbit.y * (sin(E)          );\n}\nvec3 orbitPoint(Orbit orbit, Time time)\n{\n    return orbitPoint(orbit, orbitEccentricAnomaly(orbit, time));\n}\n\nvec3 orbitVelocityDirection(Orbit orbit, float E)\n{\n    return normalize(-orbit.x * sin(E) + orbit.y * cos(E));\n}\nvec3 orbitVelocityDirection(Orbit orbit, Time time)\n{\n    return orbitVelocityDirection(orbit, orbitEccentricAnomaly(orbit, time));\n}\n\nfloat orbitVelocityMagnitude(Orbit orbit, float E)\n{\n    float f2 = dot(orbit.x, orbit.x)\n             * (1.f + orbit.e * cos(E))\n             / (1.f - orbit.e * cos(E));\n    return orbit.n * sqrt(f2);\n}\nfloat orbitVelocityMagnitude(Orbit orbit, Time time)\n{\n    return orbitVelocityMagnitude(orbit, orbitEccentricAnomaly(orbit, time));\n}\n\nvec3 orbitVelocity(Orbit orbit, float E)\n{\n    return orbitVelocityMagnitude(orbit, E) * orbitVelocityDirection(orbit, E);\n}\nvec3 orbitVelocity(Orbit orbit, Time time)\n{\n    return orbitVelocity(orbit, orbitEccentricAnomaly(orbit, time));\n}\n\nfloat fetchSatPixel(int pixelI)\n{\n    return decodeF32(texelFetch(satPointA, ivec2(pixelI % dataImageWidth, pixelI / dataImageWidth), 0));\n}\nint satBegin(int satI)\n{\n    return 2 + satI * (5 + satSampleCount * 6);\n}\nuint satID(int satI)\n{\n    return floatBitsToUint(fetchSatPixel(satBegin(satI)));\n}\nTimeInterval fetchSatTimeBegin(int satI)\n{\n    return TimeInterval\n    (\n        fetchSatPixel(satBegin(satI) + 1),\n        fetchSatPixel(satBegin(satI) + 2)\n    );\n}\nTimeInterval fetchSatTimeEnd(int satI)\n{\n    return TimeInterval\n    (\n        fetchSatPixel(satBegin(satI) + 3),\n        fetchSatPixel(satBegin(satI) + 4)\n    );\n}\nvec3 fetchSatPosition(int satI, int timeI)\n{\n    int begin = satBegin(satI) + 5;\n    return vec3\n    (\n        fetchSatPixel(begin + 6 * timeI    ),\n        fetchSatPixel(begin + 6 * timeI + 1),\n        fetchSatPixel(begin + 6 * timeI + 2)\n    );\n}\nvec3 fetchSatVelocity(int satI, int timeI)\n{\n    int begin = satBegin(satI) + 5;\n    return vec3\n    (\n        fetchSatPixel(begin + 6 * timeI + 3),\n        fetchSatPixel(begin + 6 * timeI + 4),\n        fetchSatPixel(begin + 6 * timeI + 5)\n    );\n}\nOrbit fetchSatOrbit(int timeI, int satI, Time time)\n{\n    return orbitFromVec7(vec7\n    (\n        fetchSatPosition(satI, timeI),\n        fetchSatVelocity(satI, timeI),\n        timeSinceJ2000(time)\n    ));\n}\n\nstruct OrbitPair\n{\n    float k; // interpolation coefficient, [0:1]\n    Orbit orbit[2];\n};\nOrbitPair orbitPair(int satI, Time time)\n{\n    TimeInterval t0 = fetchSatTimeBegin(satI);\n    TimeInterval t1 = fetchSatTimeEnd  (satI);\n\n    float N = float(satSampleCount - 1);\n    float k = timeUnlerp(t0, t1, timeSinceJ2000(time));\n    float n = k * N;\n\n    int i0 = clamp(int(floor(n))    , 0, satSampleCount - 1);\n    int i1 = clamp(int(floor(n)) + 1, 0, satSampleCount - 1);\n\n    Orbit orbit0 = fetchSatOrbit(i0, satI, Time(epochJ2000, timeLerp(t0, t1, float(i0) / N)));\n    Orbit orbit1 = fetchSatOrbit(i1, satI, Time(epochJ2000, timeLerp(t0, t1, float(i1) / N)));\n\n    if(i0 == i1)\n        return OrbitPair(0.f     , Orbit[2](orbit0, orbit0));\n    else\n        return OrbitPair(fract(n), Orbit[2](orbit0, orbit1));\n}\nvec3 interpolatedOrbitPoint(int satI, Time time)\n{\n    OrbitPair op = orbitPair(satI, time);\n    return mix\n    (\n        orbitPoint(op.orbit[0], time),\n        orbitPoint(op.orbit[1], time),\n        op.k\n    );\n}\nvec3 interpolatedOrbitVelocity(int satI, Time time)\n{\n    OrbitPair op = orbitPair(satI, time);\n    return mix\n    (\n        orbitVelocity(op.orbit[0], time),\n        orbitVelocity(op.orbit[1], time),\n        op.k\n    );\n}\n#line 2 19\nfloat DistributionGGX(float NH, float r)\n{\n    float nom    = r * r * r * r;\n    float denom0 = (NH * NH * (nom - 1.f) + 1.f);\n    float denom  = pi * denom0 * denom0;\n    return nom / denom;\n}\nfloat GeometrySchlickGGX(float NV, float roughness)\n{\n    float r = (roughness + 1.f);\n    float k = (r * r) / 8.f;\n\n    float nom   = NV;\n    float denom = NV * (1.f - k) + k;\n    return nom / denom;\n}\nfloat GeometrySmith(float NV, float NL, float roughness)\n{\n    float ggx1 = GeometrySchlickGGX(NL, roughness);\n    float ggx2 = GeometrySchlickGGX(NV, roughness);\n    return ggx1 * ggx2;\n}\nvec3 FresnelSchlick(float HV, vec3 F0)\n{\n    return F0 + (1.f - F0) * pow(1.f - HV, 5.f);\n}\n#line 2 23\n\n#ifdef FRAGSHADER\nvec4 sample4(float p)\n{\n    float dx = dFdx(p) * 0.25f;\n    float dy = dFdy(p) * 0.25f;\n    return vec4\n    (\n        p - dx - dy,\n        p - dx + dy,\n        p + dx - dy,\n        p + dx + dy\n    );\n}\nvec2[4] sample4(vec2 p)\n{\n    vec2 dx = dFdx(p) * 0.25f;\n    vec2 dy = dFdy(p) * 0.25f;\n    return vec2[4]\n    (\n        p - dx - dy,\n        p - dx + dy,\n        p + dx - dy,\n        p + dx + dy\n    );\n}\nvec3[4] sample4(vec3 p)\n{\n    vec3 dx = dFdx(p) * 0.25f;\n    vec3 dy = dFdy(p) * 0.25f;\n    return vec3[4]\n    (\n        p - dx - dy,\n        p - dx + dy,\n        p + dx - dy,\n        p + dx + dy\n    );\n}\n#endif\n#line 2 25\n// http://www.thetenthplanet.de/archives/4519\nfloat chapman(float x, float cosZ)\n{\n    float c = sqrt(0.5f * pi * x);\n    float sinZ = sqrt(1.f - cosZ * cosZ);\n    return cosZ >= 0.f\n        ? c / ((c - 1.f) * cosZ + 1.f)\n        : c / ((c - 1.f) * cosZ - 1.f)\n        + 2.f * c * exp(x * (1.f - sinZ)) * sqrt(sinZ);\n}\nconst float rayleighH = 8e3f;\nvec3 rayleighScattering(float x)\n{\n    const vec3 n = vec3(1.000295f, 1.000300f, 1.000307f);\n    const float N = 2.504e25f;\n    const vec3 K = 8.f / 3.f * pi * pi * pi * (n * n - 1.f) * (n * n - 1.f) / N;\n    const vec3 wl4 = 1.f / ((wl * wl) * (wl * wl));\n    return K * wl4 * exp(earthR / rayleighH - x);\n}\nfloat rayleighPhase(float cosZ)\n{\n    return 3.f / 16.f / pi * (1.f + cosZ * cosZ);\n}\nvec3 rayleighOpticalDepth(float h, float cosZ)\n{\n    float x = h / rayleighH;\n    return rayleighScattering(x) * rayleighH * chapman(x, cosZ);\n}\n\nconst uint layerCount = 5u;\nfloat layerR(uint i)\n{\n    return earthR - 4.f * rayleighH * log(1.f - float(i) / float(layerCount));\n}\nvec3 integrand(vec3 r, vec3 rayDir, vec3 lightDir)\n{\n    vec3 l = normalize(r);\n    float x = length(r) / rayleighH;\n\n    vec3 a = rayleighScattering(x);\n    float lCam = chapman(x, dot(l,   rayDir));\n    float lSun = chapman(x, dot(l, lightDir));\n    return a * exp(-a * rayleighH * (lCam + lSun));\n}\nvec3 atmoFromEarth(Ray ray, vec3 lightDir)\n{\n    float dl = dot(normalize(ray.pos), lightDir);\n    if(dl < -0.1f)\n        return vec3(0.f);\n\n    float t0 = dl < 0.f\n        ? rayCylinderIntersection(ray, Cylinder(vec3(0.f), -earthR * lightDir, earthR)).tFar\n        : 0.f;\n    vec3 f0 = integrand(rayPoint(ray, t0), ray.dir, lightDir);\n    vec3 color = vec3(0.f);\n    for(uint i = 0u; i + 1u < layerCount; ++i)\n    {\n        float t1 = raySphereIntersection(ray, Sphere(vec3(0.f), layerR(i + 1u))).tFar;\n        if(dl < 0.f && t1 <= t0)\n            continue;\n        vec3 f1 = integrand(rayPoint(ray, t1), ray.dir, lightDir);\n        color += abs(t1 - t0) * (f1 - f0) / log(f1 / f0);\n\n        t0 = t1;\n        f0 = f1;\n    }\n    return rayleighPhase(dot(ray.dir, lightDir)) * color;\n}\nvec3 atmo(Ray ray, float tFar, vec3 lightDir)\n{\n    Cylinder shadow = Cylinder(vec3(0.f), -2.f * earthR * lightDir, earthR);\n    RayDistanceRange I = rayCylinderIntersection(ray, shadow);\n\n    if(I.tNear < 0.f && tFar < I.tFar)\n        return vec3(0.f);\n\n    bool beginsInShadow = I.tNear <  0.f &&  0.f < I.tFar;\n    bool   endsInShadow = I.tNear < tFar && tFar < I.tFar;\n    float t0 = beginsInShadow\n        ? I.tFar\n        : 0.f;\n    float t1 = endsInShadow\n        ? I.tNear\n        : tFar;\n    vec3 f0 = integrand(rayPoint(ray, t0), ray.dir, lightDir);\n    vec3 f1 = integrand(rayPoint(ray, t1), ray.dir, lightDir);\n    return rayleighPhase(dot(ray.dir, lightDir)) * abs(t1 - t0) * (f1 - f0) / log(f1 / f0);\n}\n\nvec3 skyI(float x)\n{\n    const vec3 a = vec3( 0.0260596f,  0.092723f,  0.172234f);\n    const vec3 b = vec3(-0.0819419f, -0.232979f, -0.432763f);\n    const vec3 c = vec3( 0.0506876f,  0.152135f,  0.310905f);\n    const vec3 d = vec3( 0.051657f,   0.059264f,  0.060268f);\n    const vec3 e = vec3(18.1825f, 17.9718f, 15.2404f);\n    return (1.f + tanh(e * x)) *\n           (a * x * x * x\n          + b * x * x\n          + c * x\n          + d);\n}\n#line 2 26\nvec3 stationPosition(int stationI, Time time)\n{\n    vec2 a = uintBitsToFloat(texelFetch(stationA, ivec2(stationI, 0), 0).rg);\n    return 1.005f * earthR * toS2(a + vec2(GMST(time), 0.f));\n}\nuint stationID(int stationI)\n{\n    return texelFetch(stationA, ivec2(stationI, 0), 0).b;\n}\n#line 2 16\n\nuint fetchGroupU32(int i)\n{\n    return texelFetch(groupA, ivec2(i & 0xff, i >> 8), 0).r;\n}\nuint fetchGroupU8(int i)\n{\n    return uintbyte(fetchGroupU32(i >> 2), uint(i & 0x3));\n}\n\nuint     satGroup(int     satI)\n{\n    return fetchGroupU8(satI);\n}\nuint stationGroup(int stationI)\n{\n    return fetchGroupU8(256 * 4 * 256 + stationI);\n}\nuint  regionGroup(int  regionI)\n{\n    return fetchGroupU32(256 * 257 + regionI);\n}\nuint   commsGroup(int   commsI)\n{\n    return commsGroup();\n}\n\nuint regionID(int regionI)\n{\n    return fetchGroupU32(256 * 258 + regionI);\n}\nvec3 regionPosition(int regionI, Time time)\n{\n    vec2 a = uintBitsToFloat\n    (\n        uvec2\n        (\n            fetchGroupU32(256 * 259 + 2 * regionI    ),\n            fetchGroupU32(256 * 259 + 2 * regionI + 1)\n        )\n    );\n    return earthR * toS2(a + vec2(GMST(time), 0.f));\n}\n\nlowp vec3 packI24(int fourBits, int idx)\n{\n    return vec3(float((fourBits << 4) | (idx >> 16)), float((idx >> 8) & 0xff), float(idx & 0xff)) * one255;\n}\nlowp vec4 packSatIndex(int idx)\n{\n    return vec4(packI24(1, idx), 1.f);\n}\nlowp vec4 packStationIndex(int idx)\n{\n    return vec4(packI24(2, idx), 1.f);\n}\nlowp vec4 packRegionIndex(int idx)\n{\n    return vec4(packI24(3, idx), 1.f);\n}\nlowp vec4 packCommsIndex(int idx)\n{\n    return vec4(packI24(4, idx), 1.f);\n}\n\nvec4 groupColor(uint groupI)\n{\n    return decodeColor(fetchGroupU32(256 * 261 + int(groupI)));\n}\nuint groupInfo(uint groupI)\n{\n    return fetchGroupU32(256 * 262 + int(groupI));\n}\nbool groupInfoBit(uint groupI, uint bit)\n{\n    return (groupInfo(groupI) & (1u << bit)) != 0u;\n}\nuint groupPointShape(uint groupI)\n{\n    return (groupInfo(groupI) >> 5u) & 0x7u;\n}\nfloat groupPointNormalizedSize(uint groupI) // -> [0, 1]\n{\n    return float((groupInfo(groupI) >> 8u) & 0xfu) / float(0xfu);\n}\nfloat pointScreenSize(float normalizedSize)\n{\n    return mainFramebufferSize.y * (1.5e-2f * (0.1f + float(normalizedSize)));\n}\nfloat groupPointSize(uint groupI)\n{\n    return pointScreenSize(groupPointNormalizedSize(groupI));\n}\n\nbool     satPick(int     satI)\n{\n    return (pickInfo & 0xf0000000u) == 0x10000000u && ((pickInfo & 0x0fffff00u) >> 8u) == uint(satI);\n}\nbool stationPick(int stationI)\n{\n    return (pickInfo & 0xf0000000u) == 0x20000000u && ((pickInfo & 0x0fffff00u) >> 8u) == uint(stationI);\n}\nbool  regionPick(int  regionI)\n{\n    return (pickInfo & 0xf0000000u) == 0x30000000u && ((pickInfo & 0x0fffff00u) >> 8u) == uint(regionI);\n}\nbool   commsPick(int   commsI)\n{\n    return (pickInfo & 0xf0000000u) == 0x40000000u && ((pickInfo & 0x0fffff00u) >> 8u) == uint(commsI);\n}\n\nvec4  satPointColor     (int     satI) {return groupColor(satGroup(satI));}\nfloat satPointSize      (int     satI) {return (satPick(satI) ? float(pickSizeMultiplier) : 1.f) * groupPointSize(satGroup(satI));}\nuint  satPointShape     (int     satI) {return groupPointShape(satGroup(satI));}\nbool  satPointVisibility(int     satI) {return groupInfoBit(satGroup(satI), 0u);}\nbool  satOrbitVisibility(int     satI) {return groupInfoBit(satGroup(satI), 1u);}\nbool  satRenderLine     (int     satI) {return groupInfoBit(satGroup(satI), 2u);}\nbool  satRenderView     (int     satI) {return groupInfoBit(satGroup(satI), 3u);}\nbool  satRenderCapture  (int     satI) {return groupInfoBit(satGroup(satI), 4u);}\n\nvec4  stationPointColor (int stationI) {return groupColor(stationGroup(stationI));}\nfloat stationPointSize  (int stationI) {return (stationPick(stationI) ? float(pickSizeMultiplier) : 1.f) * groupPointSize(stationGroup(stationI));}\nuint  stationPointShape (int stationI) {return groupPointShape(stationGroup(stationI));}\nbool  stationVisibility (int stationI) {return groupInfoBit(stationGroup(stationI), 0u);}\n\nvec4  regionColor       (int  regionI) {return (regionPick(regionI) ? float(pickColorMultiplier) : 1.f) * groupColor(regionGroup(regionI));}\nbool  regionVisibility  (int  regionI) {return groupInfoBit(regionGroup(regionI), 0u);}\n\nvec4  commsColor     (int commsI) {return groupColor(commsGroup(commsI));}\nfloat commsPointSize (int commsI) {return groupPointSize(commsGroup(commsI));}\nuint  commsPointShape(int commsI) {return groupPointShape(commsGroup(commsI));}\nbool  commsVisibility(int commsI) {return groupInfoBit(commsGroup(commsI), 0u);}\n\nconst vec4 clipAway = vec4(0.f);\n#define CLIP_IF(x) if(x) {gl_Position = clipAway; return;}\n#line 2 17\n\nstruct Index\n{\n    int data;\n};\nint indexV(Index i) {return i.data & 0xfffff;}\nint indexK(Index i) {return i.data >> 20;} // 0: nothing\n                                           // 1: satellite\n                                           // 2: station\n                                           // 3: region\n\nIndex lookupIndex(uint ID)\n{\n    ivec2 it = ivec2(0, satelliteCount);\n    while(it[0] != it[1])\n    {\n        int mid = (it[0] + it[1]) >> 1;\n        it = ID <= satID(mid)\n            ? ivec2(it[0],     mid)\n            : ivec2(mid + 1, it[1]);\n    }\n    if(it[0] != satelliteCount && satID(it[0]) == ID)\n        return Index(0x100000 + it[0]);\n\n    it = ivec2(0, stationCount);\n    while(it[0] != it[1])\n    {\n        int mid = (it[0] + it[1]) >> 1;\n        it = ID <= stationID(mid)\n            ? ivec2(it[0],     mid)\n            : ivec2(mid + 1, it[1]);\n    }\n    if(it[0] != stationCount && stationID(it[0]) == ID)\n        return Index(0x200000 + it[0]);\n\n    it = ivec2(0, regionCount);\n    while(it[0] != it[1])\n    {\n        int mid = (it[0] + it[1]) >> 1;\n        it = ID <= regionID(mid)\n            ? ivec2(it[0],     mid)\n            : ivec2(mid + 1, it[1]);\n    }\n    if(it[0] != regionCount && regionID(it[0]) == ID)\n        return Index(0x300000 + it[0]);\n\n    return Index(0);\n}\n\nbool indexVisibility(Index i)\n{\n    switch(indexK(i))\n    {\n        case 1: return satPointVisibility(indexV(i));\n        case 2: return  stationVisibility(indexV(i));\n        case 3: return   regionVisibility(indexV(i));\n        default: return false;\n    }\n}\nvec3 indexPosition(Index i, Time t)\n{\n    switch(indexK(i))\n    {\n        case 1: return interpolatedOrbitPoint(indexV(i), t);\n        case 2: return        stationPosition(indexV(i), t);\n        case 3: return         regionPosition(indexV(i), t);\n        default: return vec3(0.f);\n    }\n}\nvec3 indexPositionNow(Index i)\n{\n    switch(indexK(i))\n    {\n        case 1: return  satPositionNow(indexV(i)     );\n        case 2: return stationPosition(indexV(i), now);\n        case 3: return  regionPosition(indexV(i), now);\n        default: return vec3(0.f);\n    }\n}\n#line 2 13\n\nlowp uvec4 fetchCommsPixel(int i)\n{\n    return texelFetch(commsA, ivec2(i % dataImageWidth, i / dataImageWidth), 0);\n}\n\nstruct CommsPack\n{\n    Index sender, receiver;\n    // J2000:\n    float days;\n    float ms0, ms1;\n    float data;\n};\n\nTimeInterval commsTime0(int packI)\n{\n    return TimeInterval\n    (\n        decodeF32(fetchCommsPixel(6 * packI + 6)),\n        decodeF32(fetchCommsPixel(6 * packI + 7))\n    );\n}\nint lookupCommsI(int k, Time time)\n{\n    ivec2 it = ivec2(0, commsCount);\n    while(it[0] != it[1])\n    {\n        int mid = (it[0] + it[1]) >> 1;\n        it = timeLessThanEqual(timeSinceJ2000(time), commsTime0(mid))\n            ? ivec2(it[0],     mid)\n            : ivec2(mid + 1, it[1]);\n    }\n    return it[0] + k - commsMaxCount;\n}\nCommsPack fetchCommsPack(int packI)\n{\n    return CommsPack\n    (\n        lookupIndex(decodeU32(fetchCommsPixel(6 * packI + 4))),\n        lookupIndex(decodeU32(fetchCommsPixel(6 * packI + 5))),\n        decodeF32(fetchCommsPixel(6 * packI + 6)),\n        decodeF32(fetchCommsPixel(6 * packI + 7)),\n        decodeF32(fetchCommsPixel(6 * packI + 8)),\n        decodeF32(fetchCommsPixel(6 * packI + 9))\n    );\n}\n\nfloat commsSizeMultiplier(float data)\n{\n    const float ymin = 0.f;\n    const float ymax = 1.f;\n    float xmin = decodeF32(texelFetch(commsA, ivec2(2, 0), 0));\n    float xmax = decodeF32(texelFetch(commsA, ivec2(3, 0), 0));\n    return clamp((log(data) - log(xmin)) / (log(xmax) - log(xmin)), 0.f, 1.f);\n}\n";
export const aabbVS: "\n#line 3 98\n\nflat out vec3 diag;\nflat out vec4 lower;\n\nflat out vec3   sunPos;\nflat out vec3 earthPos;\n\nflat out int objectI;\nflat out vec3 rayPos;\nout vec3 boxPos;\n\nvec3 act(mat4 m, vec3 v)\n{\n    vec4 u = m * vec4(v, 1.f);\n    return u.xyz / u.w;\n}\n\nvoid main()\n{\n    int satI = cameraObjectID();\n    objectI = int(satGroup(satI));\n\n    AABB box = fetchObjectMainAABB(objectI);\n    diag = box.pmax - box.pmin;\n    lower = vec4(box.pmin, max(diag.x, max(diag.y, diag.z)) / 1e3f);\n\n    // in inner coordinate system, box.pmin -> vec3(0, 0, 0), box.pmax -> vec3(1, 1, 1)\n    mat4 innerToObj = mat4\n    (\n        vec4(diag.x, 0.f, 0.f, 0.f),\n        vec4(0.f, diag.y, 0.f, 0.f),\n        vec4(0.f, 0.f, diag.z, 0.f),\n        lower\n    );\n\n    int i = int[]\n    (\n        0, 4, 6, 0, 6, 2, // -x\n        1, 3, 7, 1, 7, 5, // +x\n        0, 1, 5, 0, 5, 4, // -y\n        2, 6, 7, 2, 7, 3, // +y\n        0, 2, 3, 0, 3, 1, // -z\n        4, 5, 7, 4, 7, 6  // +z\n    )[gl_VertexID];\n\n    boxPos = vec3\n    (\n        (i & 0x1) != 0 ? 1.f : 0.f,\n        (i & 0x2) != 0 ? 1.f : 0.f,\n        (i & 0x4) != 0 ? 1.f : 0.f\n    );\n\n    vec3 objPos = satPositionNow(satI);\n\n    // object coordinate system:\n    vec3 x = normalize(         satPositionNow(cameraObjectID()) );\n    vec3 z = normalize(cross(x, satVelocityNow(cameraObjectID())));\n    vec3 y = cross(z, x);\n\n    /*\n    mat4 objToECI = mat4\n    (\n        vec4(     x, 0.f),\n        vec4(     y, 0.f),\n        vec4(     z, 0.f),\n        vec4(objPos, 1.f)\n    );\n\n    mat4 innerToECI = objToECI * innerToObj;\n    mat3 ECItoObj = transpose(mat3(objToECI));\n\n    vec3 pos = act(innerToECI, boxPos);\n    gl_Position = vec4(cameraPixel(pos), 1.f);\n\n    rayPos = act(inverse(innerToECI), cameraPos());\n\n    earthPos = -(ECItoObj * satPositionNow(cameraObjectID()));\n    sunPos = earthPos + ECItoObj * (fromEcliptic * eclipticPosition(sunEclipticCoord(now)));\n    */\n\n    mat4 objToECI = mat4\n    (\n        vec4(        x, 0.f),\n        vec4(        y, 0.f),\n        vec4(        z, 0.f),\n        vec4(vec3(0.f), 1.f)\n    );\n\n    mat4 innerToECI = objToECI * innerToObj;\n    mat3 ECItoObj = transpose(mat3(objToECI));\n\n    mat3 B = cameraBasis();\n    vec3 camPos = B[2] * camDist(mouse().z);\n    vec3 dr = satPositionNow(satI) - satPositionNow(cameraObjectID());\n    vec3 diff = act(innerToECI, boxPos) - camPos + dr;\n\n    vec3 dir = transpose(B) * diff;\n    vec2 xy = dir.xy / (fov(mouse().z) * vec2(aspectRatio, 1.f));\n    float w = -dir.z;\n    gl_Position = vec4(xy, toDepth(w) * w, w);\n\n    rayPos = act(inverse(innerToECI), camPos);\n\n    earthPos = -(ECItoObj * satPositionNow(cameraObjectID()));\n    sunPos = earthPos + ECItoObj * (fromEcliptic * eclipticPosition(sunEclipticCoord(now)));\n}\n";
export const commsLineVS: "\n#line 3 103\nflat out vec4 vColor;\nflat out vec4 vIndex;\nvoid main()\n{\n    int commsI = lookupCommsI(gl_InstanceID, now);\n    CLIP_IF(commsI < 0 || commsI >= commsCount\n         || commsVisibility(commsI) == false);\n\n    CommsPack pack = fetchCommsPack(commsI);\n    CLIP_IF(indexVisibility(pack.  sender) == false\n         || indexVisibility(pack.receiver) == false);\n\n    float k = timeUnlerp\n    (\n        TimeInterval(0.f, pack.ms0),\n        TimeInterval(0.f, pack.ms1),\n        timeDiff(timeSinceJ2000(now), TimeInterval(pack.days, 0.f))\n    );\n    CLIP_IF((0.f <= k && k <= 1.f) == false);\n\n    vec3 pos = gl_VertexID == 0\n        ? indexPositionNow(pack.  sender)\n        : indexPositionNow(pack.receiver);\n    gl_Position = vec4(cameraPixel(pos), 1.f);\n\n    vColor = commsColor(commsI);\n    vIndex = vec4(0.f);\n}\n";
export const commsPointVS: "\n#line 3 104\nflat out float pointSize;\nflat out uint pointShape;\nflat out vec2 center;\nflat out vec4 vColor;\nflat out vec4 vIndex;\nvoid main()\n{\n    int commsI = lookupCommsI(gl_InstanceID, now);\n    CLIP_IF(commsI < 0 || commsI >= commsCount\n         || commsVisibility(commsI) == false);\n\n    CommsPack pack = fetchCommsPack(commsI);\n    CLIP_IF(indexVisibility(pack.  sender) == false\n         || indexVisibility(pack.receiver) == false);\n\n    float k = timeUnlerp\n    (\n        TimeInterval(0.f, pack.ms0),\n        TimeInterval(0.f, pack.ms1),\n        timeDiff(timeSinceJ2000(now), TimeInterval(pack.days, 0.f))\n    );\n    CLIP_IF((0.f <= k && k <= 1.f) == false);\n\n    vec3 pos = mix\n    (\n        indexPositionNow(pack.  sender),\n        indexPositionNow(pack.receiver),\n        k\n    );\n    vec3 vp = cameraPixel(pos);\n\n    uint group = commsGroup(commsI);\n    float size = groupPointNormalizedSize(group) * commsSizeMultiplier(pack.data);\n    pointSize = pointScreenSize(max(commsPointMinimalSize(), size));\n\n    pointShape = groupPointShape(group);\n    center = 0.5f + 0.5f * vp.xy;\n    vColor = groupColor(group);\n    vIndex = packCommsIndex(commsI);\n\n    gl_Position = vec4(vp, 1.f);\n    gl_PointSize = pointSize;\n}\n";
export const earthVS: "\n#line 2 100\nflat out vec3   sunPos;\nflat out vec3  moonPos;\nflat out vec3 earthPos;\n\nvoid main()\n{\n    sunPos  = fromEcliptic * eclipticPosition( sunEclipticCoord(now));\n    moonPos = fromEcliptic * eclipticPosition(moonEclipticCoord(now));\n    earthPos = vec3(0.f);\n\n    vec2 p = vec2[]\n    (\n        vec2(-1.f, -1.f),\n        vec2(-1.f,  1.f),\n        vec2( 1.f, -1.f),\n        vec2( 1.f, -1.f),\n        vec2(-1.f,  1.f),\n        vec2( 1.f,  1.f)\n    )[gl_VertexID];\n\n    gl_Position = vec4(p, 0.f, 1.f);\n}\n";
export const moonVS: "\n#line 2 100\nflat out vec3 sunDir;\nflat out float sunAngle;\n\nflat out vec3 moonPos;\nflat out mat3 moonRot;\n\nvoid main()\n{\n    EclipticCoord sunCoord = sunEclipticCoord(now);\n    sunDir = fromEcliptic * toS2(sunCoord.coord);\n    sunAngle = sunR / sunCoord.dist;\n\n    EclipticCoord moonCoord = moonEclipticCoord(now);\n    moonPos = moonCoord.dist * (fromEcliptic * toS2(moonCoord.coord));\n\n    moonRot = fromEcliptic * moonRotation(now);\n\n    vec3 pos = cameraPixel(moonPos);\n    float camDist = length(moonPos - cameraPos());\n    vec2 r = mainFramebufferSize.yx / mainFramebufferSize.xx / fov(mouse().z)\n           * moonR * inversesqrt(camDist * camDist - moonR * moonR);\n\n    vec2 p = vec2[]\n    (\n        vec2(-1.f, -1.f),\n        vec2(-1.f,  1.f),\n        vec2( 1.f, -1.f),\n        vec2( 1.f, -1.f),\n        vec2(-1.f,  1.f),\n        vec2( 1.f,  1.f)\n    )[gl_VertexID];\n\n    gl_Position = vec4(pos + vec3(r * p, 0.f), 1.f);\n}\n";
export const orbitVS: "\n#line 2 106\nuniform uint orbitPointCount;\nflat out vec4 vColor;\nflat out vec4 vIndex;\nvoid main()\n{\n    CLIP_IF(satPointVisibility(gl_InstanceID) == false\n         || satOrbitVisibility(gl_InstanceID) == false);\n\n    vec7 v = vec7\n    (\n        satPositionNow(gl_InstanceID),\n        satVelocityNow(gl_InstanceID),\n        timeSinceJ2000(now)\n    );\n    Orbit orbit = orbitFromVec7(v);\n    float E = orbitEccentricAnomaly(orbit, now);\n\n    float k = float(gl_VertexID) / float(orbitPointCount);\n    vec3 pos = orbitPoint(orbit, E + 2.f * pi * k);\n\n    gl_Position = vec4(cameraPixel(pos), 1.f);\n    vColor = satPointColor(gl_InstanceID);\n    vIndex = vec4(0.f);\n}\n";
export const polygonVS: "\n#line 2 107\nflat out vec4 vColor;\nvoid main()\n{\n    vec2 uv = toUV(texelFetch(polygonA, ivec2(gl_VertexID, 0), 0).rg)\n            - vec2(float(gl_InstanceID), 0.f);\n    gl_Position = vec4(-1.f + 2.f * uv, 0.f, 1.f);\n    vColor = vec4(one255, 0.f, 0.f, 0.f);\n}\n";
export const quadVS: "\n#line 2 108\nout vec2 pos;\nvoid main()\n{\n    pos = vec2[]\n    (\n        vec2(-1.f, -1.f),\n        vec2(-1.f,  1.f),\n        vec2( 1.f, -1.f),\n        vec2( 1.f, -1.f),\n        vec2(-1.f,  1.f),\n        vec2( 1.f,  1.f)\n    )[gl_VertexID];\n    gl_Position = vec4(pos, 1.f, 1.f);\n}\n";
export const satCaptureVS: "\n#line 2 110\nflat out vec4 vColor;\nvoid main()\n{\n    CameraInfo info = cameraInfo(gl_InstanceID);\n    CLIP_IF(satPointVisibility(info.satelliteID) == false\n         || satRenderCapture  (info.satelliteID) == false);\n\n    bool upper = bool[](false,  true, false, false,  true, true)[gl_VertexID % 6];\n    bool right = bool[](false, false,  true,  true, false, true)[gl_VertexID % 6];\n\n    vec3 p0 = satPositionNow(info.satelliteID);\n    vec2 c0 = toUV(fromS2(rotateZ(GMST(now)) * normalize(p0)));\n\n    float gmst = upper ? GMST(now) : GMST(prev);\n\n    vec3 pos = upper\n        ? p0\n        : satPositionPrev(info.satelliteID);\n    vec3 v = upper\n        ? satVelocityNow (info.satelliteID)\n        : satVelocityPrev(info.satelliteID);\n\n    vec3 z = normalize(pos);\n    vec3 y = normalize(v);\n    vec3 x = normalize(cross(y, z));\n\n    vec2 phi = info.captureOrientation;\n    float k = upper ? phi.x : phi.y;\n    float mid = (1.f - k) * info.viewAngle[0] + k * info.viewAngle[1];\n    float w = info.captureAngle * 0.5f;\n\n    float a = (gl_VertexID / 6) % 2 != 0\n        ? (right ? mid + w : mid)\n        : (right ? mid : mid - w);\n    Ray ray = Ray\n    (\n        pos,\n        sin(a) * x - cos(a) * z\n    );\n\n    const Sphere earth = Sphere(vec3(0.f), earthR);\n    RayDistanceRange I = raySphereIntersection(ray, earth);\n    vec3 p = rayPoint(ray, I.tNear);\n    vec2 c = toUV(fromS2(rotateZ(gmst) * normalize(p)));\n\n    if(c0.x > 0.75f || c0.x < 0.25f)\n    {\n        if(gl_VertexID < 12 && c.x > 0.5f)\n            c.x -= 1.f;\n        else if(gl_VertexID >= 12 && c.x < 0.5f)\n            c.x += 1.f;\n    }\n    gl_Position = vec4(-1.f + 2.f * c, 0.f, 1.f);\n    vColor = vec4(0.f, 0.f, 1.f, 0.f);\n}\n";
export const satLineVS: "\n#line 2 112\nflat out vec4 vColor;\nvoid main()\n{\n    CLIP_IF(satPointVisibility(gl_InstanceID) == false\n         || satRenderLine     (gl_InstanceID) == false);\n\n    vec3 pos0 = satPositionNow (gl_InstanceID);\n    vec3 pos1 = satPositionPrev(gl_InstanceID);\n    vec2 a0 = fromS2(rotateZ(GMST(now )) * normalize(pos0));\n    vec2 a1 = fromS2(rotateZ(GMST(prev)) * normalize(pos1));\n    vec2 c0 = toUV(a0);\n    vec2 c1 = toUV(a1);\n    const float du = 0.25f;\n    if(c0.x < du && c1.x > 1.f - du)\n    {\n        if(gl_VertexID < 2)\n            c1.x -= 1.f;\n        else\n            c0.x += 1.f;\n    }\n    if(c1.x < du && c0.x > 1.f - du)\n    {\n        if(gl_VertexID < 2)\n            c0.x -= 1.f;\n        else\n            c1.x += 1.f;\n    }\n    vec2 c = gl_VertexID % 2 == 0 ? c0 : c1;\n    gl_Position = vec4(-1.f + 2.f * c, 0.f, 1.f);\n    vColor = vec4(1.f, 0.f, 0.f, 0.f);\n}\n";
export const satViewVS: "\n#line 2 113\nflat out vec4 vColor;\nvoid main()\n{\n    CameraInfo info = cameraInfo(gl_InstanceID);\n    CLIP_IF(satPointVisibility(info.satelliteID) == false\n         || satRenderView     (info.satelliteID) == false);\n\n    bool upper = bool[](false,  true, false, false,  true, true)[gl_VertexID % 6];\n    bool right = bool[](false, false,  true,  true, false, true)[gl_VertexID % 6];\n\n    vec3 p0 = satPositionNow(info.satelliteID);\n    vec2 c0 = toUV(fromS2(rotateZ(GMST(now)) * normalize(p0)));\n\n    float gmst = upper ? GMST(now) : GMST(prev);\n\n    vec3 pos = upper\n        ? p0\n        : satPositionPrev(info.satelliteID);\n    vec3 v = upper\n        ? satVelocityNow (info.satelliteID)\n        : satVelocityPrev(info.satelliteID);\n\n    vec3 z = normalize(pos);\n    vec3 y = normalize(v);\n    vec3 x = normalize(cross(y, z));\n\n    float midAngle = 0.5f * (info.viewAngle[0] + info.viewAngle[1]);\n    float a = (gl_VertexID / 6) % 2 != 0\n        ? (right ? info.viewAngle[1] : midAngle)\n        : (right ? midAngle : info.viewAngle[0]);\n    Ray ray = Ray\n    (\n        pos,\n        sin(a) * x - cos(a) * z\n    );\n\n    const Sphere earth = Sphere(vec3(0.f), earthR);\n    RayDistanceRange I = raySphereIntersection(ray, earth);\n    vec3 p = rayPoint(ray, I.tNear);\n    vec2 c = toUV(fromS2(rotateZ(gmst) * normalize(p)));\n\n    if(c0.x > 0.75f || c0.x < 0.25f)\n    {\n        if(gl_VertexID < 12 && c.x > 0.5f)\n            c.x -= 1.f;\n        else if(gl_VertexID >= 12 && c.x < 0.5f)\n            c.x += 1.f;\n    }\n    gl_Position = vec4(-1.f + 2.f * c, 0.f, 1.f);\n    vColor = vec4(0.f, 1.f, 0.f, 0.f);\n}\n";
export const satelliteVS: "\n#line 2 114\nflat out float pointSize;\nflat out uint pointShape;\nflat out vec2 center;\nflat out vec4 vColor;\nflat out vec4 vIndex;\nvoid main()\n{\n    CLIP_IF(satPointVisibility(gl_InstanceID) == false);\n\n    vec3 pos = satPositionNow(gl_InstanceID);\n    vec3 vp = cameraPixel(pos);\n\n    pointSize = satPointSize(gl_InstanceID);\n    pointShape = satPointShape(gl_InstanceID);\n    center = 0.5f + 0.5f * vp.xy;\n    vColor = vec4(satPointColor(gl_InstanceID).rgb, 1.f);\n    vIndex = packSatIndex(gl_InstanceID);\n\n    gl_Position = vec4(vp, 1.f);\n    gl_PointSize = pointSize;\n}\n";
export const stationVS: "\n#line 2 115\nflat out float pointSize;\nflat out uint pointShape;\nflat out vec2 center;\nflat out vec4 vColor;\nflat out vec4 vIndex;\nvoid main()\n{\n    CLIP_IF(stationVisibility(gl_InstanceID) == false);\n\n    vec3 pos = cameraPixel(stationPosition(gl_InstanceID, now));\n\n    pointSize = stationPointSize(gl_InstanceID);\n    pointShape = stationPointShape(gl_InstanceID);\n    center = 0.5f + 0.5f * pos.xy;\n    vColor = vec4(stationPointColor(gl_InstanceID).rgb, 1.f);\n    vIndex = packStationIndex(gl_InstanceID);\n\n    gl_Position = vec4(pos, 1.f);\n    gl_PointSize = pointSize;\n}\n";
export const viewTriangleVS: "\n#line 2 118\nvoid main()\n{\n    CameraInfo info = cameraInfo(gl_InstanceID);\n    CLIP_IF(satPointVisibility(info.satelliteID) == false\n         || satRenderView     (info.satelliteID) == false);\n\n    vec3 pos0 = satPositionNow(info.satelliteID);\n    if(gl_VertexID == 2)\n        gl_Position = vec4(cameraPixel(pos0), 1.f);\n    else\n    {\n        vec3 z = normalize(pos0);\n        vec3 y = normalize(satVelocityNow(info.satelliteID));\n        vec3 x = normalize(cross(y, z));\n        y = cross(z, x);\n\n        float a = info.viewAngle[gl_VertexID % 2];\n        Ray ray = Ray\n        (\n            pos0,\n            sin(a) * x - cos(a) * z\n        );\n        RayDistanceRange I = raySphereIntersection(ray, Sphere(vec3(0.f), earthR));\n\n        float t = happened(I) ? I.tNear : length(pos0);\n        gl_Position = vec4(cameraPixel(rayPoint(ray, t)), 1.f);\n    }\n}\n";
export const captureFS: "\n#line 3 100\n\nlayout(location = 0) out uvec3 color;\n\nvoid main()\n{\n    ivec2 framebufferExtent = ivec2\n    (\n        min(4096, cameraCount),\n        int(ceil(float(cameraCount) / 4096.f))\n    );\n    ivec2 p = clamp(ivec2(gl_FragCoord.xy), ivec2(0), framebufferExtent - 1);\n    int cameraI = p.y * 4096 + p.x;\n    color = uvec3\n    (\n        floatBitsToUint(interpolatedAngle(cameraI, now )),\n        floatBitsToUint(interpolatedAngle(cameraI, prev)),\n        uint(indexV(lookupIndex(decodeU32(fetchCapturePixel(cameraCount + 2 + 4 * cameraI)))))\n    );\n}\n";
export const circleFS: "\n#line 3 101\n\nflat in vec2 center;\nflat in float pointSize;\nflat in uint pointShape;\nflat in vec4 vColor;\nflat in vec4 vIndex;\n\nlayout(location = 0) out vec4 oColor;\nlayout(location = 1) out vec4 oIndex;\n\nbool inside(vec2 a)\n{\n    switch(pointShape)\n    {\n        case 0u: return dot(a, a) < 0.25f;\n        case 1u: return dot(a, a) < 0.25f && dot(a, a) > 0.1f;\n        case 2u: return true;\n        case 3u: return abs(a.x) > 0.3f || abs(a.y) > 0.3f;\n        case 4u: return abs(a.x) + abs(a.y) < 0.5f;\n        case 5u: return abs(a.x) + abs(a.y) < 0.5f && abs(a.x) + abs(a.y) > 0.35f;\n        case 6u: return abs(a.x) - 0.5f * abs(a.y + 0.5f) < 0.05f;\n        case 7u: return abs(a.x - a.y) < 0.15f || abs(a.x + a.y) < 0.15f;\n        default: return false;\n    }\n}\n\nvoid main()\n{\n    oColor = vec4(vColor.rgb, 0.f);\n    oIndex = vIndex;\n    for(uint i = 0u; i < 4u; ++i)\n        if(inside((sample4(gl_FragCoord.xy - center * mainFramebufferSize)[i]) / pointSize))\n            oColor.a += 0.25f;\n}\n";
export const earthFS: "\n#line 3 105\n\nflat in vec3   sunPos;\nflat in vec3  moonPos;\nflat in vec3 earthPos;\n\nlayout(location = 0) out vec4 oColor;\nlayout(location = 1) out vec4 oIndex;\n\nconst float     sunI = 1366.f;\nconst float   starsI =  200.f;\nconst float surfaceI =   80.f;\nconst float    gridI =   1.5f;\n\nvec3 premultiply(vec4 color)\n{\n    return color.rgb * color.a;\n}\nvec3 surfaceColor(vec2 tex)\n{\n    vec4 surface = texture(surfaceA, tex);\n    vec3 color = surface.r * premultiply(decodeColor(   satLineColor))\n               + surface.g * premultiply(decodeColor(   satViewColor))\n               + surface.b * premultiply(decodeColor(satCaptureColor));\n\n    float a = texelFetch(surfaceA, ivec2(tex * surfaceFramebufferSize), 0).a;\n    int region = int(255.f * a) - 1;\n    if(region != -1 && regionVisibility(region))\n    {\n        oIndex = packRegionIndex(region);\n        color += premultiply(regionColor(region));\n    }\n    return color;\n}\n\nvec3 earthColor(Ray ray)\n{\n    RayDistanceRange E = raySphereIntersection(ray, Sphere(earthPos, earthR));\n    vec3 pos = rayPoint(ray, E.tNear);\n    gl_FragDepth = min(gl_FragDepth, pointDepth(pos));\n\n    vec3 norm = normalize(pos - earthPos);\n    pos = earthPos + norm * earthR; // more precision? maybe\n\n    vec2 tex = toUV(fromS2(rotateZ(GMST(now)) * norm));\n    vec3 albedo = texture(earthA, tex).rgb\n                + texture(bordrA, tex).r * premultiply(decodeColor(borderLineColor));\n\n    bool isWater = albedo.r + albedo.g < albedo.b;\n    float roughness = isWater ? 0.65f : 1.f;\n\n    vec3 light = normalize(sunPos - earthPos);\n    vec3 view = -ray.dir;\n    vec3 halfway = normalize(light + view);\n\n    const float e = 1e-4f;\n    float NL = max(e, dot(norm,   light));\n    float NV = max(e, dot(norm,    view));\n    float NH = max(e, dot(norm, halfway));\n    float HV = max(e, dot(halfway, view));\n\n    float NDF = DistributionGGX(NH, roughness);\n    float G = GeometrySmith(NV, NL, roughness);\n    float specular = NDF * G / (4.f * NV * NL);\n\n    vec3 F = FresnelSchlick(HV, vec3(0.02f));\n\n    vec3 kIn  = exp(-rayleighOpticalDepth(earthR, dot(norm, light)));\n    vec3 kOut = exp(-rayleighOpticalDepth(earthR, dot(norm,  view)));\n\n    vec3 brdfD = albedo * (1.f - F) / pi;\n    vec3 brdfS = F * specular;\n    vec3 c = isPretty()\n        ? ( (spectralToSRGB * (kOut * kIn)) * NL * (brdfD + brdfS)\n          + brdfD * (spectralToSRGB * (kOut * skyI(dot(norm, light))))\n          + spectralToSRGB * atmoFromEarth(Ray(pos, view), light)\n          ) * lightVisibility(pos, Sphere(sunPos, sunR), Sphere(moonPos, moonR))\n        : albedo / pi;\n    if(abs(dot(norm, light)) < 1e-3f)\n        c += surfaceI * premultiply(decodeColor(sunsetLineColor));\n\n    return sunI * sunSpectral * c + surfaceColor(tex) * surfaceI;\n}\nvec3 atmoColor(Ray ray)\n{\n    RayDistanceRange A = raySphereIntersection(ray, Sphere(earthPos, earthR + atmoH));\n    vec3 light = normalize(sunPos - earthPos);\n\n    float tMid = 0.5f * (A.tNear + A.tFar);\n    float dt = 0.4f * (A.tFar - tMid); // shortened\n    vec3 pos = rayPoint(ray, tMid);\n\n    vec3 a = atmo(Ray(pos - earthPos,  ray.dir), dt, light)\n           + atmo(Ray(pos - earthPos, -ray.dir), dt, light);\n    return isPretty()\n        ? lightVisibility\n        (\n            pos,\n            Sphere( sunPos,  sunR),\n            Sphere(moonPos, moonR)\n        ) * spectralToSRGB * (sunI * sunSpectral * a)\n        : vec3(0.f);\n}\nvec3 sunColor(Ray ray)\n{\n    vec3 light = normalize(sunPos - ray.pos);\n    float sunSin2 = sunR * sunR / (sunR * sunR + dot(sunPos - ray.pos, sunPos - ray.pos));\n\n    float cosA = dot(ray.dir, light);\n    float sinA = sqrt(1.f - cosA * cosA);\n    float o = acos(cosA) * 180.f / pi;\n    float o2 = o + 0.02f;\n\n    float f0 = 0.384f * 2.f / sunSin2;\n    float f1 = 0.478f * 20.91195f / (o2 * o2 * o2) * sinA;\n    float f2 = 0.138f * 72.37457f / (o2 * o2) * sinA;\n\n    bool onSun = cosA > 0.f && (1.f - cosA * cosA) < sunSin2;\n\n    return sunSRGB * 20.f * (onSun ? f0 : f1 + f2);\n}\nvec3 starColor(Ray ray)\n{\n    vec2 uv = toUV(fromS2(ray.dir));\n    uv = vec2(1.f - uv.x, uv.y);\n    return starsI * texture(starsA, uv).rgb\n         + starsI * texture(milkyA, uv).rgb * 0.05f\n         +  gridI * texture( gridA, uv).rrr;\n}\n\nvec3 earthRayColor(Ray ray)\n{\n    RayDistanceRange E = raySphereIntersection(ray, Sphere(earthPos, earthR        ));\n    RayDistanceRange A = raySphereIntersection(ray, Sphere(earthPos, earthR + atmoH));\n\n    bool earthHit = happened(E);\n    bool  atmoHit = happened(A);\n\n    vec3 color = earthHit\n        ? earthColor(ray)\n        : sunColor(ray) + starColor(ray);\n    return !earthHit && atmoHit\n        ? color + atmoColor(ray)\n        : color;\n}\n\nvoid main()\n{\n    gl_FragDepth = 1.f;\n    oIndex = vec4(0.f);\n\n    uint sampleCount = isMultisampled() ? 4u : 1u;\n    vec2 p[4] = sample4(-1.f + 2.f * gl_FragCoord.xy / mainFramebufferSize.xy);\n\n    vec4 color = vec4(0.f);\n    for(uint i = 0u; i < sampleCount; ++i)\n    {\n        vec3 c = earthRayColor(cameraRay(p[i]));\n        color += vec4(expose(c.rgb), 1.f);\n    }\n    color /= float(sampleCount);\n    oColor = vec4(encodeSRGB(color.rgb), color.a);\n}\n";
export const moonFS: "\n#line 2 99\nflat in vec3 sunDir;\nflat in float sunAngle;\nflat in vec3 moonPos;\nflat in mat3 moonRot;\n\nlayout(location = 0) out vec4 oColor;\nlayout(location = 1) out vec4 oIndex;\n\nfloat moonBRDF(vec3 norm, vec3 eye, vec3 light)\n{\n    float cosPhi = dot(eye, light);\n    float sinPhi = sqrt(1.f - cosPhi * cosPhi);\n    float tanPhi = sinPhi / cosPhi;\n    float cotPhi = cosPhi / sinPhi;\n\n    float NV = dot(norm,   eye);\n    float NL = dot(norm, light);\n\n    const float g = 0.6f;\n    float B = cosPhi > 0.f\n        ? 2.f - (1.f - exp(-g * cotPhi)) * (3.f - exp(-g * cotPhi)) / (2.f * g * cotPhi)\n        : 1.f;\n    float S = (sinPhi + (pi - abs(atan(sinPhi, cosPhi))) * cosPhi) / pi + 0.1f * (1.f - 0.5f * cosPhi) * (1.f - 0.5f * cosPhi);\n    return NL >= 0.f ? 2.f / (3.f * pi) * B * S / (1.f + NV / NL) : 0.f;\n}\nvec4 moonColor(Ray ray)\n{\n    Sphere moon = Sphere(moonPos, moonR);\n    RayDistanceRange I = raySphereIntersection(ray, moon);\n\n    if(happened(I))\n    {\n        vec3 p = ray.pos + ray.dir * I.tNear;\n        gl_FragDepth = min(gl_FragDepth, pointDepth(p));\n\n        vec3 earthDir = normalize(-p);\n        vec3 norm = normalize(p - moonPos);\n        vec2 tex = toUV(fromS2(moonRot * norm));\n        vec3 albedo = vec3(1.35f, 1.f, 0.7f) * texture(moonA, tex).r / pi;\n\n        float L = lightVisibility\n        (\n            p,\n            Sphere(sunDir * (sunR / sunAngle), sunR),\n            Sphere(vec3(0.f), earthR)\n        ) * 1905.f * moonBRDF(norm, -ray.dir, sunDir);\n\n        // earthshine:\n        float cosPhase = dot(-ray.dir, sunDir);\n        float sinPhase = sqrt(1.f - cosPhase * cosPhase);\n        float a = pi - atan(sinPhase, cosPhase);\n        float E = 20.f * moonBRDF(norm, -ray.dir, earthDir) * (1.f + sin(a * 0.5f) * tan(a * 0.5f) * log(tan(a * 0.25f)));\n\n        return vec4(albedo * (L + E), 1.f);\n    }\n    return vec4(0.f);\n}\nvoid main()\n{\n    gl_FragDepth = 1.f;\n    vec2 p[4] = sample4(-1.f + 2.f * gl_FragCoord.xy / mainFramebufferSize.xy);\n\n    vec3 color = vec3(0.f);\n    float alpha = 0.f;\n    for(uint i = 0u; i < 4u; ++i)\n    {\n        vec4 c = moonColor(cameraRay(p[i]));\n        color += expose(c.rgb);\n        alpha += c.a * 0.25f;\n    }\n\n    oColor = vec4(encodeSRGB(0.25f * color), alpha);\n    oIndex = vec4(0.f);\n}\n";
export const objectFS: "\n#line 2 113\n\nflat in vec3 diag;\nflat in vec4 lower;\n\nflat in vec3   sunPos;\nflat in vec3 earthPos;\n\nflat in int objectI;\n\nflat in vec3 rayPos;\nin vec3 boxPos;\n\nlayout(location = 0) out vec4 oColor;\nlayout(location = 1) out vec4 oIndex;\n\nvec3 innerToObj(vec3 v)\n{\n    return (v * diag + lower.xyz) / lower.w;\n}\nvec3 innerToObjDir(vec3 v)\n{\n    return normalize(v * diag);\n}\nvec3 objToInnerDir(vec3 v)\n{\n    return normalize(v / diag);\n}\n\nvec3 offsetPoint(vec3 pos, vec3 norm)\n{\n    const float intScale = 256.f;\n    const float floatScale = 1.f / 65536.f;\n    const float origin = 1.f / 32.f;\n\n    vec3 n = norm * intScale;\n    ivec3 of = ivec3(int(n.x), int(n.y), int(n.z));\n    vec3 p = vec3\n    (\n        intBitsToFloat(floatBitsToInt(pos.x) + (pos.x < 0.f ? -of[0] : of[0])),\n        intBitsToFloat(floatBitsToInt(pos.y) + (pos.y < 0.f ? -of[1] : of[1])),\n        intBitsToFloat(floatBitsToInt(pos.z) + (pos.z < 0.f ? -of[2] : of[2]))\n    );\n    return vec3\n    (\n        abs(pos.x) < origin ? pos.x + floatScale * n.x : p.x,\n        abs(pos.y) < origin ? pos.y + floatScale * n.y : p.y,\n        abs(pos.z) < origin ? pos.z + floatScale * n.z : p.z\n    );\n}\nvec4 color(Ray ray)\n{\n    RayObjectIntersection i = rayObjectIntersection(objectI, ray, RayDistanceRange(0.f, 100.f));\n\n    if(!happened(i))\n        return vec4(0.f);\n\n    Triangle t = fetchObjectTriangle(objectI, i.triangleID);\n    vec3 norm = fetchObjectNorm(objectI, i.triangleID, i.rti);\n    vec3 pos = ray.pos + ray.dir * i.rti.t;\n\n    vec3 light = normalize(sunPos - pos);\n    Ray shadowRay = Ray(offsetPoint(pos, 8.f * norm), objToInnerDir(light));\n\n    float shadowMult = happened(rayObjectIntersection(objectI, shadowRay, RayDistanceRange(0.f, 4.f)))\n        ? 0.f\n        : lightVisibility\n        (\n            innerToObj(shadowRay.pos),\n            Sphere(  sunPos,   sunR),\n            Sphere(earthPos, earthR)\n        );\n\n    Material material = fetchTriangleMaterial(objectI, i.triangleID);\n\n    norm = innerToObjDir(norm);\n    vec3 view = innerToObjDir(-ray.dir);\n    vec3 halfway = normalize(light + view);\n\n    const float e = 1e-4f;\n    float NL = max(e, dot(norm,    light));\n    float NV = max(e, dot(norm,     view));\n    float NH = max(e, dot(norm,  halfway));\n    float HV = max(e, dot(halfway,  view));\n    float LH = max(e, dot(light, halfway));\n\n    vec3 ambient = material.albedo * max(e, dot(norm, view));\n\n    if(isPretty())\n    {\n        float NDF = DistributionGGX(NH, material.roughness);\n        float G = GeometrySmith(NV, NL, material.roughness);\n        float specular = NDF * G / (4.f * NV * NL);\n\n        vec3 F = FresnelSchlick(HV, mix(vec3(0.04f), material.albedo, material.metalness));\n\n        vec3 brdfD = material.albedo * (1.f - F) * (1.f - material.metalness) / pi;\n        vec3 brdfS = F * specular;\n\n        return vec4(ambient + shadowMult * 1300.f * NL * (brdfD + brdfS), 1.f);\n    }\n    else\n        return vec4(ambient * 100.f, 1.f);\n}\nvoid main()\n{\n    vec4 accum = vec4(0.f);\n    vec3[4] pos = sample4(boxPos);\n    uint sampleCount = isMultisampled() ? 4u : 1u;\n    for(uint i = 0u; i < sampleCount; ++i)\n    {\n        vec4 c = color(Ray(rayPos, normalize(pos[i] - rayPos)));\n        accum += vec4(expose(c.rgb), c.a) / float(sampleCount);\n    }\n    if(accum.a == 0.f)\n        discard;\n    oColor = vec4(encodeSRGB(accum.rgb / accum.a), accum.a);\n    oIndex = vec4(0.f);\n}\n";
export const regionFS: "\n#line 2 109\n\nin vec2 pos;\n\nlayout(location = 0) out vec4 color;\n\nuniform int idx;\n\nvoid main()\n{\n    bool inside = int(texture(regionA, 0.5f + 0.5f * pos).r * 255.f) % 2 == 1;\n    if(!inside)\n        discard;\n    color = vec4(0.f, 0.f, 0.f, float(idx + 1) * one255);\n}\n";
export const satCoordFS: "\n#line 3 111\nlayout(location = 0) out uvec4 color;\nvoid main()\n{\n    ivec2 framebufferExtent = ivec2\n    (\n        min(4096, satelliteCount),\n        4 * int(ceil(float(satelliteCount) / 4096.f))\n    );\n    ivec2 p = clamp(ivec2(gl_FragCoord.xy), ivec2(0), framebufferExtent - 1);\n    int satI = p.x + (p.y / 4) * 4096;\n    switch(p.y % 4)\n    {\n        case 0: color.rgb = floatBitsToUint(interpolatedOrbitPoint   (satI, now )); break;\n        case 1: color.rgb = floatBitsToUint(interpolatedOrbitVelocity(satI, now )); break;\n        case 2: color.rgb = floatBitsToUint(interpolatedOrbitPoint   (satI, prev)); break;\n        case 3: color.rgb = floatBitsToUint(interpolatedOrbitVelocity(satI, prev)); break;\n    }\n}\n";
export const uColorFS: "\n#line 2 116\nuniform vec4 uColor;\nlayout(location = 0) out vec4 oColor;\nlayout(location = 1) out vec4 oIndex;\nvoid main()\n{\n    oColor = uColor;\n    oIndex = vec4(0.f);\n}\n";
export const vColorFS: "\n#line 2 117\nflat in vec4 vColor;\nlayout(location = 0) out vec4 oColor;\nlayout(location = 1) out vec4 oIndex;\nvoid main()\n{\n    oColor = vColor;\n    oIndex = vec4(0.f);\n}\n";
